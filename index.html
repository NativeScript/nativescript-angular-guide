<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Building Apps with NativeScript and Angular 2</title>

	<meta charset="utf-8">
	<meta name="description" content="A guide to getting started building apps with NativeScript and Angular 2">
	<meta name="author" content="TJ VanToll">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>
<body>

<div id="container">
	<div id="header">
		<a href="#" class="menu header-btn" id="toggle-toc"></a>
		<h1>Building Apps with NativeScript and Angular 2</h1>
		<a href="https://github.com/nativescript/nativescript-angular-guide" class="github header-btn"></a>
	</div>

	<div id="content-container">
		<div id="toc">
			<div class="toc-heading">Table of Contents</div>
			<div id="toc-padding"></div>
		</div>
		<div id="book">
			<div class="chapter">
				<h2 id="building-apps-with-nativescript-and-angular-2">Building Apps with NativeScript and Angular 2</h2>
<p>Welcome to the NativeScript &amp; Angular 2 getting started guide ğŸ“š. In this hands-on tutorial, youâ€™ll build a cross-platform iOS and Android app from scratch.</p>
<blockquote>
<p><strong>IMPORTANT</strong>: NativeScriptâ€™s Angular integration is in beta. If you run into any issues completing this guide, please log those issues on our <a href="https://github.com/NativeScript/nativescript-angular/issues">nativescript-angular GitHub repo</a>.</p>
</blockquote>
<h3 id="what-is-nativescript-what-is-angular-2-">What is NativeScript? What is Angular 2?</h3>
<div class="intro-box">
  <img src="images/chapter0/NativeScript_logo.png" class="plain" alt="NativeScript logo">
  <p><a href="https://www.nativescript.org/">NativeScript</a>  is a framework for building native iOS and Android apps using JavaScript and CSS. NativeScript renders UIs with the native platformâ€™s rendering engineâ€”no <a href="http://developer.telerik.com/featured/what-is-a-webview/">WebViews</a>â€”resulting in native-like performance and UX.</p>
</div>

<div class="intro-box">
  <img src="images/chapter0/Angular_logo.png" class="plain" alt="Angular logo">
  <p><a href="https://angularjs.org/">Angular JS</a> is one of the most popular open source JavaScript frameworks for application development. The latest version of Angular, <a href="https://angular.io/">Angular 2</a>, makes it possible to use Angular outside of a web browser, and developers at <a href="http://www.telerik.com/">Telerik</a>â€”the company that created and maintains NativeScriptâ€”<a href="https://docs.google.com/document/d/1J6fZcVbVa6uONVCJIox2A3Jn5TWgspLufmryfA1OXGk/edit#heading=h.trgonlvb0z3j">have been working closely with developers at Google</a> to make Angular 2 in NativeScript a reality.</p>
</div>

<div class="intro-box">
  <img src="images/chapter0/NativeScript_Angular_logo.png" class="plain" alt="Angular logo">
  <p>The result is a software architecture that allows you to build mobile apps using the same frameworkâ€”and in some cases the same codeâ€”that you use to build Angular 2 web apps, with the performance youâ€™d expect from native code. Letâ€™s look at how it all works by building an app.</p>
</div>

<h3 id="what-you-re-building">What you&#39;re building</h3>
<p>This guide will walk you through building <a href="https://github.com/NativeScript/sample-Groceries">Groceries</a>, a groceries management app that does the following things:</p>
<ul>
<li>Connects to an existing RESTful service.</li>
<li>Provides user registration and login.</li>
<li>Lets authenticated users add and delete groceries from a list.</li>
<li>Runs cross-platform (iOS and Android).</li>
</ul>
<p>If you follow along to the end, here&#39;s what the finished app will look like on iOS:</p>
<p><img src="images/chapter0/ios/1.png" alt="Final look of iOS app 1" style="height: 300px;">
<img src="images/chapter0/ios/2.png" alt="Final look of iOS app 1" style="height: 300px;">
<img src="images/chapter0/ios/3.png" alt="Final look of iOS app 1" style="height: 300px;"></p>
<p>And here&#39;s what the app will look like on Android:</p>
<p><img src="images/chapter0/android/1.png" alt="Final look of Android app 1" style="height: 300px;">
<img src="images/chapter0/android/2.png" alt="Final look of Android app 1" style="height: 300px;">
<img src="images/chapter0/android/3.png" alt="Final look of Android app 1" style="height: 300px;"></p>
<h3 id="prerequisites">Prerequisites</h3>
<p>This guide assumes that you have some basic knowledge of JavaScript, CSS, and your development machineâ€™s terminal. More specifically:</p>
<ul>
<li><strong>JavaScript</strong>: You should know basic JavaScript concepts, such as how functions, if statements, and loops work.</li>
<li><strong>CSS</strong>: You should know how to write simple CSS selectors, and know how to apply CSS rules as name/value pairs.</li>
<li><strong>The terminal</strong>: You should know how to open a terminal or command-line prompt on your development machine, how to change directories, and how to execute commands.</li>
<li><strong>A text editor or IDE</strong>: You should know the basics of your text editor or IDE of choice. You can use any text editor to build NativeScript apps, however, for the best possible experience you may want an editor with built-in TypeScript support, such as <a href="https://code.visualstudio.com/">Visual Studio Code</a>.</li>
</ul>
<p>This guide will <em>not</em> assume you have any knowledge of Angular 2 or TypeScript. When background Angular 2 or TypeScript expertise will help you understand a concept, this guide will link you to the appropriate places in the <a href="https://angular.io/docs/ts/latest/">Angular</a> or <a href="http://www.typescriptlang.org/Handbook">TypeScript</a> documentation.</p>
<p>With that out of the way, letâ€™s get started!</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="getting-up-and-running">Getting up and running</h2>
<p>In this chapter you&#39;re going to start with the basics, including installing the NativeScript command-line interface, starting a new project, and getting your first app up and running.</p>
<h3 id="install-nativescript-and-configure-your-environment">Install NativeScript and configure your environment</h3>
<p>The NativeScript CLI has a few system requirements you must have in place before building NativeScript apps. Letâ€™s look at the steps youâ€™ll need to take to get up and running.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Setup NativeScript
</h4>

<p><strong>Step 1: Install Node.js</strong></p>
<p>The NativeScript CLI is built on Node.js, and as such you need to have Node.js installed to use NativeScript.</p>
<p>You can check whether you have Node.js setup by opening a terminal or command prompt on your development machine and executing <code>node --version</code>. If you get an error, head to the <a href="https://nodejs.org/">https://nodejs.org/</a> and download and install the latest â€œLTSâ€ (long-term support) distribution for your development machine.</p>
<blockquote>
<p><strong>TIP</strong>: The NativeScript CLI supports a wide variety of Node.js versions, so if you already have Node.js installed you should be good to go. If, by chance, youâ€™re running an unsupported version, the <code>tns doctor</code> command weâ€™ll run momentarily will flag the problem so you can upgrade.</p>
</blockquote>
<p><strong>Step 2: Install the NativeScript CLI</strong></p>
<p>Open your terminal or command prompt and execute the following command to install the NativeScript CLI from npm, which is Node.jsâ€™ package manager:</p>
<pre><code>npm install -g nativescript
</code></pre><p>After completing the setup you should have two commands available from your terminal or command prompt: <code>tns</code>â€”which is short for <b>T</b>elerik <b>N</b>ative<b>S</b>criptâ€”and <code>nativescript</code>. The two commands are equivalent, so we&#39;ll stick with the shorter <code>tns</code>.</p>
<p>You can verify the installation was successful by running <code>tns</code> in your terminal. You should see something like this:</p>
<div class="no-copy-button"></div>

<pre><code>$ tns
# NativeScript
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Usage   â”‚ Synopsis                                                            â”‚
â”‚ General â”‚ $ tns &lt;Command&gt; [Command Parameters] [--command &lt;Options&gt;]          â”‚
â”‚ Alias   â”‚ $ nativescript &lt;Command&gt; [Command Parameters] [--command &lt;Options&gt;] â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><p><strong>Step 3: Install iOS and Android requirements</strong></p>
<p>When you build with NativeScript youâ€™re building truly native iOS and Android apps, and as such, you need to setup each platform you intend to build for on your development machine. To ease the pain of installing all of these requirements manually, the NativeScript CLI provides quick-start scripts for Windows and OS X that handle the necessary setup for you automatically. Letâ€™s look at how they work.</p>
<blockquote>
<p><strong>NOTE</strong>: If you have existing mobile experience, if youâ€™re on Linux, or if you want full control of the installation process, refer to one of the advanced setup guide below, which walk you through manually setting up your environment for NativeScript development.</p>
<ul>
<li><a href="http://docs.nativescript.org/start/ns-setup-win#setup">Advanced setup: Windows</a></li>
<li><a href="http://docs.nativescript.org/start/ns-setup-os-x#setup">Advanced setup: OS X</a></li>
<li><a href="http://docs.nativescript.org/start/ns-setup-linux#setup">Advanced setup: Linux</a></li>
</ul>
</blockquote>
<p><u>Windows</u></p>
<p>If youâ€™re on Windows, copy and paste the script below into your command prompt and press Enter:</p>
<pre><code>@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((new-object net.webclient).DownloadString(&#39;https://raw.githubusercontent.com/NativeScript/nativescript-cli/production/setup/native-script.ps1&#39;))&quot;
</code></pre><p>During installation you may need to accept a User Account Control prompt to grant the script administrative privileges. Also, be aware that the script downloads and installs some big dependenciesâ€”so itâ€™s common for the script to take a while to complete.</p>
<p><u>OS X</u></p>
<p>If youâ€™re on a Mac, copy and paste the script below into your terminal and press Enter:</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/NativeScript/nativescript-cli/production/setup/native-script.rb)&quot;
</code></pre><p>Much like the Windows script, the OS X script needs administrative access to run some commands using <code>sudo</code>; therefore, you may need to provide your password several times during execution. The OS X script also may take some time to complete, as itâ€™s installing the dependencies for both iOS and Android development.</p>
<p><strong>Step 4: Verify the setup</strong></p>
<p>Once youâ€™ve finished installing NativeScript and its dependencies, run the <code>tns doctor</code> command, which will check for any issues with your installation.</p>
<pre><code>tns doctor
</code></pre><p>If you see â€œNo issues were detectedâ€ youâ€™re good to go!</p>
<div class="exercise-end"></div>

<p>Regardless of which approach you take, setting up your machine for native development can be tricky. If you get stuck, or if you have questions at any point while going through this guide, the <a href="http://developer.telerik.com/wp-login.php?action=slack-invitation">NativeScript Community Slack channel</a> is a great place to ask questions.</p>
<h3 id="start-your-app">Start your app</h3>
<p>With the NativeScript CLI installed, it&#39;s time to start building your app. Normally, you would <a href="https://github.com/NativeScript/NativeScript-cli#create-project">use the <code>tns create</code> command to create an empty NativeScript application</a>. For this guide however, we&#39;ve scaffolded out a boilerplate project to act as a starting point for <a href="https://github.com/NativeScript/sample-Groceries">Groceries</a>.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Get the Groceries starting point
</h4>

<p>Navigate to a folder where you want to keep your app code:</p>
<div class="no-copy-button"></div>

<pre><code>cd the-folder-you-want-groceries-to-be-in
</code></pre><p>Next, assuming you have <a href="http://www.git-scm.com/">git installed</a>, clone the Groceries repo from GitHub:</p>
<pre><code>git clone https://github.com/NativeScript/sample-Groceries.git
</code></pre><p>After that, change to the newly cloned repo&#39;s folder:</p>
<pre><code>cd sample-Groceries
</code></pre><p>Finally, switch to the â€œangular-startâ€ branch for this guide&#39;s starting point:</p>
<pre><code>git checkout angular-start
</code></pre><div class="exercise-end"></div>

<blockquote>
<p><strong>TIP:</strong></p>
<ul>
<li>The â€œangular-endâ€ branch has the final state of this guide&#39;s tutorial. Feel free to <a href="https://github.com/NativeScript/sample-Groceries/tree/angular-end">refer to the branch on GitHub</a> if you get stuck.</li>
<li>After completing this guide, if youâ€™d like to start a new NativeScript and Angular 2 appâ€”one that doesnâ€™t clone Groceriesâ€”you can use the NativeScript CLIâ€™s <code>tns create</code> command as such:<pre><code>tns create my-app-name --template tns-template-hello-world-ng
</code></pre></li>
</ul>
</blockquote>
<h3 id="add-target-development-platforms">Add target development platforms</h3>
<p>Your app is now set up, but before you run it, you need to initialize a platform-specific native project for each platform you intend to target.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add the iOS and Android platforms
</h4>

<p>If you&#39;re on a Mac, start by adding the iOS platform:</p>
<pre><code>tns platform add ios
</code></pre><p>Next, add the Android platform with the same <code>platform add</code> command:</p>
<pre><code>tns platform add android
</code></pre><div class="exercise-end"></div>

<blockquote>
<p><strong>IMPORTANT:</strong> You can add platforms only for SDKs that you already have installed on your development machine. If you get errors running <code>tns platform add</code>, refer back to the section on <a href="#install-nativescript-and-configure-your-environment">setting up your development environment</a>.</p>
</blockquote>
<p>The <code>platform add</code> command adds a folder called <code>platforms</code> to your project, and copies all of the required native SDKs into this folder. When you build the application, the NativeScript CLI will copy your application code into the <code>platforms</code> folder so that a native binary can be created.</p>
<h3 id="running-your-app">Running your app</h3>
<p>With the platform initialization complete, you can run your app in an emulator or on devices.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Run your app
</h4>

<p>If you&#39;re on a Mac, start by running the app in an iOS simulator with the following command:</p>
<pre><code>tns run ios --emulator
</code></pre><p>If all went well, you should see something like this:</p>
<p><img src="images/chapter1/ios/1.png" alt="iOS login"></p>
<p>Next, run your app on an Android emulator with the following command:</p>
<pre><code>tns run android --emulator
</code></pre><blockquote>
<p><strong>WARNING</strong>:</p>
<ul>
<li>You must have at least one Android AVD (Android Virtual Device) configured for this command to work. If you get an error, try <a href="http://developer.telerik.com/featured/using-android-emulator-hybrid-mobile-apps-telerik-appbuilder/#managing-avds">setting up an AVD</a> and then run the command again.</li>
<li>If you&#39;re using <a href="https://www.genymotion.com">Genymotion</a>, launch your Genymotion virtual device first, and then run <code>tns run android</code> to deploy your app.</li>
</ul>
</blockquote>
<p>If all went well, you should see your app running in an Android emulator:</p>
<p><img src="images/chapter1/android/1.png" alt="Android login"></p>
<div class="exercise-end"></div>

<p>Here are a few other tips for running NativeScript apps.</p>
<blockquote>
<p><strong>TIP</strong>:</p>
<ul>
<li>To run on a USB-connected Android or iOS device, use the same <code>run</code> command without the <code>--emulator</code> flagâ€”i.e. <code>tns run android</code> and <code>tns run ios</code>.</li>
<li>The <code>tns device</code> command lists all USB-connected iOS devices, USB-connected Android devices, and Genymotion virtual devices that <code>tns run</code> can deploy to. Note that <code>tns device</code> does not list iOS simulators.</li>
</ul>
</blockquote>
<h3 id="development-workflow">Development workflow</h3>
<p>At this point, you have the NativeScript CLI downloaded and installed, as well as the iOS and Android dependencies that you need to run your app. Now you need a good workflow that lets you make changes and see results fast. For that weâ€™ll use the <code>tns livesync</code> command.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Your first NativeScript change
</h4>

<p>If your previous <code>tns run ios</code> or <code>tns run android</code> task is still running, type <code>Ctrl+C</code> in your terminal to kill it.</p>
<p>If youâ€™re on a Mac, start an iOS livesync watcher by executing the following command:</p>
<pre><code>tns livesync ios --emulator --watch
</code></pre><p>If you have your app running on an Android emulator, start an Android livesync watcher by executing the following command:</p>
<pre><code>tns livesync android --emulator --watch
</code></pre><p>If you instead have your app running on a USB-connected Android device or Genymotion virtual device, run the same command without the <code>--emulator</code> flag:</p>
<pre><code>tns livesync android --watch
</code></pre><p>The <code>tns livesync</code> command updates your app by transferring the updated source code to the device or simulator. By adding the <code>--watch</code> flag, the <code>livesync</code> command additionally watches the files in your NativeScript project. Whenever one of those files changes, the command detects the update, and patches your app with the updated code.</p>
<blockquote>
<p><strong>TIP</strong>: You can learn about how this is possible by reading more about <a href="http://developer.telerik.com/featured/nativescript-works/">how NativeScript works</a>.</p>
</blockquote>
<p>To see livesync in action letâ€™s make a small update to your app. Open your projectâ€™s <code>app/app.component.ts</code> file in your text editor of choice, and replace the fileâ€™s contents with the code below, which updates the labelâ€™s text:</p>
<pre><code class="lang-TypeScript">import {Component} from &quot;angular2/core&quot;;

@Component({
  selector: &quot;my-app&quot;,
  template: &quot;&lt;Label text=&#39;hello NativeScript&#39;&gt;&lt;/Label&gt;&quot;
})
export class AppComponent {}
</code></pre>
<p>Save <code>app/app.component.ts</code> and you should see the app relaunch and the updated text displayed.</p>
<p><img src="images/chapter1/ios/2.png" alt="Updated iOS text">
<img src="images/chapter1/android/2.png" alt="Updated Android text"></p>
<div class="exercise-end"></div> 

<p>Regardless of whether youâ€™re running on iOS or Android, or whether youâ€™re using <code>tns livesync</code> or <code>tns run</code>, the NativeScript CLI shows the output of <code>console.log()</code> statements as your app executes, as well as stack traces when things go wrong. So if your app crashes at any time during this guide, look to the terminal for a detailed report of the problem.</p>
<p>The iOS and Android logs can be a bit noisy, so you might have to scroll up a bit to find the actual problem. For example if I try to call <code>foo.bar()</code> when <code>foo</code> does not exist, here&#39;s the information I get on iOS:</p>
<pre><code>/app/path/to/file.js:14:8: JS ERROR ReferenceError: Can&#39;t find variable: foo
1   0xe3dc0 NativeScript::FFICallback&lt;NativeScript::ObjCMethodCallback&gt;::ffiClosureCallback(ffi_cif*, void*, void**, void*)
</code></pre><p>And here&#39;s the same information in the Android logs:</p>
<pre><code>E/TNS.Native( 2063): ReferenceError: foo is not defined
E/TNS.Native( 2063): File: &quot;/data/data/org.nativescript.groceries/files/app/./views/login/login.js, line: 13, column: 4
</code></pre><blockquote>
<p><strong>TIP</strong>: When you&#39;re trying to debug a problem, try adding <code>console.log()</code> statements in your JavaScript codeâ€”exactly as you would in a browser-based application.</p>
<p><strong>WARNING</strong>: Not all changes can be livesyncâ€™d in a NativeScript app. For instance, livesync cannot patch native configuration file changes (<code>Info.plist</code>, <code>AndroidManifest.xml</code>, and so forth), new plugin installations, and any other change that requires a full compilation of the application. In those cases, youâ€™ll want to use <code>Ctrl+C</code> to stop livesync, and rerun the application using the <code>tns run ios</code> or <code>tns run android</code> commands. Donâ€™t worry though; when situations that require a full compilation come up in this guide, these instructions will be explicitly listed.</p>
</blockquote>
<p>Now that you&#39;ve created an app, configured your environment, and set up your app to run on iOS and Android, you&#39;re ready to start digging into the files that make up a NativeScript app.</p>

			</div>
			<div class="chapter">
				<h2 id="building-the-ui">Building the UI</h2>
<p>Before you start coding the Groceries app it&#39;s important to understand a NativeScript app&#39;s folder structure. It&#39;ll help you understand where to place new files, as well as a bit of what&#39;s going on with NativeScript under the hood.</p>
<p>Go ahead and open your app&#39;s <code>sample-Groceries</code> folder in your text editor of choice and let&#39;s dig in.</p>
<h3 id="directory-structure">Directory structure</h3>
<p>To keep things simple, let&#39;s start by looking at the outer structure of the Groceries app:</p>
<pre><code>.
â””â”€â”€ sample-Groceries
    â”œâ”€â”€ app
    â”‚   â””â”€â”€ ...
    â”œâ”€â”€ hooks
    â”‚   â””â”€â”€ ...
    â”œâ”€â”€ node_modules
    â”‚   â”œâ”€â”€ angular2
    â”‚   â”œâ”€â”€ nativescript-angular
    â”‚   â”œâ”€â”€ tns-core-modules
    â”‚   â””â”€â”€ ...
    â”œâ”€â”€ platforms
    â”‚   â”œâ”€â”€ android
    â”‚   â””â”€â”€ ios
    â”œâ”€â”€ package.json
    â”œâ”€â”€ references.d.ts
    â””â”€â”€ tsconfig.json
</code></pre><p>Here&#39;s what these various files and folders do:</p>
<ul>
<li><strong>app</strong>: This folder contains all the development resources you need to build your app. You&#39;ll be spending most of your time editing the files in here.</li>
<li><strong>hooks</strong>: This folder contains a series of files the NativeScript CLI uses to preprocess TypeScript code into JavaScript code. You can ignore this folder for now, but after you complete this tutorial you may want to experiment with other preprocessors that NativeScript provides out of the box, such as <a href="http://docs.nativescript.org/core-concepts/transpilers#installing-babel">Babel for JavaScript</a> or <a href="http://www.nativescriptsnacks.com/more/2016/03/14/less-sass.html">SASS for CSS</a>.</li>
<li><strong>node_modules</strong>: This folder contains your app&#39;s npm module dependencies, including Angular 2, TypeScript, and the other modules NativeScript needs to build your app.</li>
<li><strong>node_modules/angular2</strong>: This folder contains the Angular 2 source code. NativeScript does not alter the core Angular 2 source code in any way, instead, NativeScript builds on top of Angular 2 with the nativescript-angular npm module.</li>
<li><strong>node_modules/nativescript-angular</strong>: This folder contains the module that integrates NativeScript-specific functionality into Angular 2. The source code for this module lives at <a href="https://github.com/NativeScript/nativescript-angular">https://github.com/NativeScript/nativescript-angular</a>.</li>
<li><strong>node_modules/tns-core-modules</strong>: This folder contains your app&#39;s NativeScript modules, which are a series of NativeScript-provided JavaScript modules you&#39;ll use to build your app. Each module contains the platform-specific code needed to implement some featureâ€”the camera, http calls, the file system, and so forthâ€”exposed through a platform-agnostic API (e.g. <code>camera.takePicture()</code>). We&#39;ll look at some examples in <a href="#chapter4">chapter 4</a>. The source code for these modules lives at <a href="https://github.com/NativeScript/nativescript">https://github.com/NativeScript/nativescript</a>.</li>
<li><strong>platforms</strong>: This folder contains the platform-specific code NativeScript needs to build native iOS and Android apps. For example in the <code>android</code> folder you&#39;ll find things like your project&#39;s <code>AndroidManifest.xml</code> and .apk executable files. Similarly, the <code>ios</code> folder contains the Groceries&#39; Xcode project and .ipa executables. Note, users on Windows and Linux machines will not have an <code>ios</code> folder.</li>
<li><strong>package.json</strong>: This file contains your app&#39;s configuration details, such as your app id, the version of NativeScript you&#39;re using, and also which npm modules your app uses. We&#39;ll take a closer look at how to use this file when we talk about using npm modules in <a href="#plugins-and-npm-modules">chapter 5</a>.</li>
<li><strong>references.d.ts</strong>: This file lists all <a href="http://www.typescriptlang.org/docs/handbook/writing-definition-files.html">TypeScript declaration files</a> that your app uses. Weâ€™ll dig into what declaration files are, and how to use them in chapter 4 when we discuss NativeScript modules.</li>
<li><strong>tsconfig.json</strong>: This file contains your appâ€™s TypeScript configuration. Unless you have existing TypeScript expertise, youâ€™ll probably want to leave this file alone for now. If you do have existing experience you may want to tweak these values to suit your personal preferences. However, note that the <code>&quot;experimentalDecorators&quot;</code> and <code>&quot;emitDecoratorMetadata&quot;</code> flags are essential to making NativeScript and Angular 2 work, so donâ€™t remove those. You can refer to the official TypeScript wiki for <a href="https://github.com/Microsoft/TypeScript/wiki/tsconfig.json">detailed documentation on what you can do in a <code>tsconfig.json</code> file</a>.</li>
</ul>
<p>The NativeScript CLI manages the <code>platforms</code> folder for you as you develop and run your app; therefore, it&#39;s a best practice to treat the <code>platforms</code> folder as generated code. The Groceries app includes the <code>platforms</code> folder in its <a href="https://github.com/NativeScript/sample-Groceries/blob/master/.gitignore"><code>.gitignore</code></a> to exclude its files from source control.</p>
<p>Next, let&#39;s dig into the <code>app</code> folder, as that&#39;s where you&#39;ll be spending the majority of your time.</p>
<pre><code>.
â””â”€â”€ sample-Groceries
    â”œâ”€â”€ app
    â”‚   â”œâ”€â”€ App_Resources
    â”‚   â”‚   â”œâ”€â”€ Android
    â”‚   â”‚   â””â”€â”€ iOS
    â”‚   â”œâ”€â”€ pages
    â”‚   â”‚   â”œâ”€â”€ login
    â”‚   â”‚   â”‚   â”œâ”€â”€ login.html
    â”‚   â”‚   â”‚   â””â”€â”€ ...
    â”‚   â”‚   â””â”€â”€ ...
    â”‚   â”œâ”€â”€ shared
    â”‚   â”‚   â””â”€â”€ ...
    â”‚   â”œâ”€â”€ utils
    â”‚   â”‚   â””â”€â”€ ...
    â”‚   â”œâ”€â”€ app.css
    â”‚   â”œâ”€â”€ app.component.ts
    â”‚   â”œâ”€â”€ main.ts
    â”‚   â””â”€â”€ ...
    â””â”€â”€ ...
</code></pre><p>Here&#39;s what these various files and folders do:</p>
<ul>
<li><strong>App_Resources</strong>: This folder contains platform-specific resources such as icons, splash screens, and configuration files. The NativeScript CLI takes care of injecting these resources into the appropriate places in the <code>platforms</code> folder when you execute <code>tns run</code>.</li>
<li><strong>pages</strong>: This folder, specific to the Groceries app, contains the code to build your app&#39;s pages. Each page is made up of a TypeScript file, an optional HTML file, and an optional set of CSS files. The Groceries app starts with two folders for its two pages, a login page, and a list page.</li>
<li><strong>shared</strong>: This folder, also specific to the Groceries app, contains any files you need to share between NativeScript apps and Angular-2-built web apps. For Groceries this includes a few classes for talking to backend services, some model objects, and a <code>config.ts</code> file used to share configuration variables like API keys. Weâ€™ll discuss the <code>shared</code> folder, as well as code sharing between native apps and web apps, in detail in <a href="#chapter-3.2">chapter 3.2</a>.</li>
<li><strong>app.css</strong>: This file contains global styles for your app. We&#39;ll dig into app styling in <a href="#chapter-2.3">chapter 2.3</a>.</li>
<li><strong>app.component.ts</strong>: This primary Angular component that drives your application. Eventually this file will handle routing and application-wide configuration, however for now the file has a simple hello world example that weâ€™ll look at momentarily.</li>
<li><strong>main.ts</strong>: The starting point of Angular 2 applicationsâ€”web and native.</li>
</ul>
<p>To get a sense of how a NativeScript app actually starts up, letâ€™s explore the first few files.</p>
<h3 id="starting-up">Starting up</h3>
<p>The first few files you run in a NativeScript app look almost identical to <a href="https://angular.io/docs/ts/latest/quickstart.html">the first few files you run in an Angular 2 web app</a>. Letâ€™s start with <code>main.ts</code> as thatâ€™s the first file executed. Open your <code>app.main.ts</code> file; you should see the code below:</p>
<pre><code class="lang-JavaScript">import {nativeScriptBootstrap} from &quot;nativescript-angular/application&quot;;
import {AppComponent} from &quot;./app.component&quot;;

nativeScriptBootstrap(AppComponent);
</code></pre>
<p>Here youâ€™re using the TypeScript <code>import</code> command to bring in a functionâ€”<code>nativescriptBootstrap()</code>â€”and a <a href="http://www.typescriptlang.org/Handbook#classes">TypeScript class</a>â€”<code>AppComponent</code>â€”each of which are defined in separate files. The <code>nativescriptBootstrap()</code> function comes from the â€œnativescript-angularâ€ npm module, which you may recall contains the code needed to integrate NativeScript and Angular 2. Whereas <a href="https://angular.io/docs/ts/latest/api/platform/browser/bootstrap-function.html">Angular 2â€™s own <code>bootstrap()</code> function</a> starts an Angular 2 browser app, NativeScriptâ€™s bootstrap function starts an Angular 2 native app.</p>
<blockquote>
<p><strong>TIP</strong>: If youâ€™re curious about what <code>nativescriptBootstrap()</code> function actually has to do to startup native iOS and Android apps, remember that all this code is open source for you to explore at any time. The <code>nativescriptBootstrap()</code> function specifically is defined in an <a href="https://github.com/NativeScript/nativescript-angular/blob/master/src/nativescript-angular/application.ts"><code>application.ts</code> file</a> in the <a href="https://github.com/NativeScript/nativescript-angular">NativeScript/nativescript-angular repository</a> on GitHub.</p>
</blockquote>
<p>The bootstrap function, regardless of whether itâ€™s for the web or for native apps, needs to know which Angular component to start the application with. In this case, youâ€™re passing control to a <code>AppComponent</code> component defined in <code>app.component.ts</code>.</p>
<blockquote>
<p><strong>TIP</strong>: In a NativeScript app you can follow the same code conventions you would in an Angular 2 web app. Here weâ€™re using Angular 2â€™s own convention of naming component files with a <code>.component.ts</code> suffix.</p>
</blockquote>
<p>Next, open your appâ€™s <code>app/app.component.ts</code> file; you should see the code below:</p>
<pre><code class="lang-JavaScript">import {Component} from &quot;angular2/core&quot;;

@Component({
  selector: &quot;my-app&quot;,
  template: &quot;&lt;Label text=&#39;hello NativeScript&#39;&gt;&lt;/Label&gt;&quot;
})
export class AppComponent {}
</code></pre>
<p>This file contains an Angular 2 component, which is the primary building block of Angular 2 applications, including NativeScript apps. Letâ€™s break down whatâ€™s going on in this file.</p>
<p>First, you again use TypeScriptâ€™s <code>import</code> command to bring in externally defined functionalityâ€”in this case, the <code>Component</code> class from Angular 2 itself. In Angular 2 a component manages a view, or a piece of the user interface that the user sees. A component can be used to define an individual UI element, or an entire page, and eventually youâ€™ll add a bunch of logic to these components and use them to build an entire app. But for now this component is simple for the purpose of demonstration.</p>
<blockquote>
<p><strong>NOTE</strong>: Why <a href="http://www.typescriptlang.org/">TypeScript</a>? Itâ€™s strongly recommended that you use TypeScript in your Angular 2 NativeScript app, as itâ€™s a first class citizen in both NativeScript and Angular 2. In fact, both NativeScript and Angular 2 were built with TypeScript. The NativeScript CLI makes compiling your TypeScript files seamless, as each time you livesync, run or build the app, the files are recompiled from TypeScript to JavaScript. In some IDEs, such as Visual Studio Code, you might choose to <a href="https://code.visualstudio.com/Docs/languages/typescript#_hiding-derived-javascript-files">hide your projectâ€™s compiled JavaScript files</a> so you can focus on the TypeScript code.</p>
</blockquote>
<p>Notice the interesting way that the <code>Component</code> class is usedâ€”with the syntax <code>@Component</code>. This is a <a href="https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md">TypeScript decorator</a>, which allows you to annotate a TypeScript class or method with additional information. For now, you can think of it as a way of adding some metadata configuration to the currently empty <code>AppComponent</code> class. Specifically, the <code>@Component</code> decoratorâ€™s <code>template</code> property tells NativeScript how to render this component on the screen. In fact, the <code>&lt;Label text=&quot;hello NativeScript&quot;&gt;&lt;/Label&gt;</code> syntax is why you saw â€œhello NativeScriptâ€ when you ran this app earlier.</p>
<p>However, this syntax may look a bit odd if you come from a web development background. On the web, the <code>&lt;label&gt;</code> HTML element doesnâ€™t have a <code>text</code> attribute, so why do we see it here? Letâ€™s dive into this by looking at how NativeScript UI elements work.</p>
<blockquote>
<p><strong>NOTE</strong>: Curious about the <code>@Component</code> decoratorâ€™s <code>selector</code> property? The property defines how a component can be used within another componentâ€™s template. For instance a component that defines its <code>selector</code> with <code>selector: &quot;foo-bar&quot;</code> can be used by another component as <code>template: &quot;&lt;foo-bar&gt;&lt;/foo-bar&gt;&quot;</code>. NativeScript is smart enough to use your first Angular 2 component automatically; therefore, the <code>selector</code> property of this first component is irrelevant.</p>
</blockquote>
<h3 id="adding-ui-elements">Adding UI elements</h3>
<p>The primary difference between building an Angular 2 app for the web and an Angular 2 app with NativeScript is in the UI elements that you use. NativeScript apps do not use a browser and do not have a DOM; therefore, elements like <code>&lt;div&gt;</code> and <code>&lt;span&gt;</code> simply do not work.</p>
<p>No worries though, as NativeScript provides an <a href="http://docs.nativescript.org/ui/ui-views">extensive suite of UI elements</a>, each of which are implemented with native iOS and Android controls. For instance, the <a href="http://docs.nativescript.org/ui/ui-views#label"><code>&lt;Label&gt;</code> control</a> our previous example used is actually rendered as a <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UILabel_Class/"><code>UILabel</code></a> on iOS and an <a href="http://developer.android.com/reference/android/widget/TextView.html"><code>android.widget.TextView</code></a> on Android. The great thing about using NativeScript though, is that this native details are transparent to use as a developer. You type <code>&lt;Label&gt;</code> and let NativeScript handle the rendering details.</p>
<p>Letâ€™s return back to building Groceries. The first screen of Groceries is intended to be a login screen, so letâ€™s replace the current <code>&lt;Label&gt;</code> with something that resembles a typical login screen in a mobile app.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add UI elements to <code>app.component.ts</code>
</h4>

<p>Open <code>app/app.component.ts</code> and replace the existing <code>@Component</code> with the following code:</p>
<pre><code class="lang-JavaScript">@Component({
  selector: &quot;my-app&quot;,
  template: `
    &lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot;
      autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
    &lt;TextField hint=&quot;Password&quot; secure=&quot;true&quot;&gt;&lt;/TextField&gt;

    &lt;Button text=&quot;Sign in&quot;&gt;&lt;/Button&gt;
    &lt;Button text=&quot;Sign up for Groceries&quot;&gt;&lt;/Button&gt;
  `
})
</code></pre>
<div class="exercise-end"></div>

<blockquote>
<p><strong>NOTE</strong>: Notice the back-tick character (`) used with the <code>template</code> property. This character is used to define an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">ES2015 template literal</a>, which TypeScript supports, and which allows you to write multi-line strings without using messy string concatenation.</p>
<p><strong>WARNING</strong>: Take special care to properly close all your UI elements and <em>not</em> use self-closing declarations like <code>&lt;Button text=&quot;Sign in&quot; /&gt;</code>. The limitation is related to the <a href="https://github.com/inikulin/parse5">parse5 library</a> Angular 2 uses to parse templates, and you can read <a href="https://github.com/NativeScript/nativescript-angular#known-issues">details about the issue on GitHub</a>.</p>
</blockquote>
<p>This code adds two new NativeScript UI elements: a <a href="http://docs.nativescript.org/ApiReference/ui/text-field/how-to.html">text field</a> and a <a href="http://docs.nativescript.org/ApiReference/ui/button/how-to.html">button</a>. Much like HTML elements, NativeScript UI elements provide attributes to let you configure their behavior and appearance. The code you just added uses the following attributes:</p>
<ul>
<li><code>&lt;TextField&gt;</code><ul>
<li><code>hint</code>: Shows placeholder text that tells the user what to type.</li>
<li><code>keyboardType</code>: The type of keyboard to present to the user for input. <code>keyboardType=&quot;email&quot;</code> shows a keyboard optimized for entering email addresses. NativeScript currently supports <a href="http://docs.nativescript.org/ui/keyboard.html">five types of keyboards</a> for text fields.</li>
<li><code>autocorrect</code>: A boolean attribute that determines whether the mobile operating system should autocorrect user input. In the case of email address text fields, the autocorrect behavior is undesirable.</li>
<li><code>autocapitalizationType</code>: Determines how the operating system should autocapitalize user input. <code>autocapitalizationType=&quot;none&quot;</code> turns autocapitalization off altogether. NativeScript supports <a href="http://docs.nativescript.org/ApiReference/ui/enums/AutocapitalizationType/README.html">four autocapitalization types</a> on text fields.</li>
<li><code>secure</code>: A boolean attribute that determines whether the text fieldâ€™s text should be masked, which is commonly done on password fields.</li>
</ul>
</li>
<li><code>&lt;Button&gt;</code><ul>
<li><code>text</code>: Controls the text displayed within the button.</li>
</ul>
</li>
</ul>
<p>After your app updates with this change, you may expect to see a polished login screen, but instead you will see a single <code>&lt;Button&gt;</code> element on the screen:</p>
<p><img src="images/chapter2/ios/1.png" alt="login 1">
<img src="images/chapter2/android/1.png" alt="login 1"></p>
<p>What went wrong? In NativeScript whenever you use more than one UI element, you need to tell NativeScript how to arrange those elements on the screen. Since youâ€™re not doing that currently, NativeScript is incorrectly assuming you want the last elementâ€”the <code>&lt;Button&gt;</code>â€”to take up the whole screen. To arrange these elements, letâ€™s move onto the NativeScript feature for aligning elements on the screen: NativeScript layouts.</p>
<blockquote>
<p><strong>TIP</strong>: The NativeScript docs include a <a href="http://docs.nativescript.org/ui-with-xml">full list of the UI components and attributes</a> with which you can build your apps. You can even <a href="http://docs.nativescript.org/ui-with-xml#custom-components">build your own, custom UI components</a>.</p>
</blockquote>
<h3 id="layouts">Layouts</h3>
<p>NativeScript provides several different layout containers that allow you to place UI elements precisely where you want them to appear. </p>
<ul>
<li>The <a href="http://docs.nativescript.org/ApiReference/ui/layouts/absolute-layout/HOW-TO.html">Absolute Layout</a> lets you position elements using explicit x and y coordinates. This is useful when you need to place elements in exact locations, for example showing an activity indicator widget in the top-left corner of your app.</li>
<li>The <a href="http://docs.nativescript.org/ApiReference/ui/layouts/dock-layout/HOW-TO.html">Dock Layout</a> is useful for placing UI elements at the outer edges of your app. For example, a container docked at the bottom of the screen would be a good location for an ad.</li>
<li>The <a href="http://docs.nativescript.org/ApiReference/ui/layouts/grid-layout/HOW-TO.html">Grid Layout</a> lets you divide your interface into a series of rows and columns, much like a <code>&lt;table&gt;</code> in HTML markup.</li>
<li>The <a href="http://docs.nativescript.org/ApiReference/ui/layouts/stack-layout/HOW-TO.html">Stack Layout</a> lets you stack child UI elements either vertically or horizontally.</li>
<li>The <a href="http://docs.nativescript.org/ApiReference/ui/layouts/wrap-layout/HOW-TO.html">Wrap Layout</a> lets child UI elements flow from one row or column to the next when space is filled.</li>
</ul>
<p>For your login screen, all you need is a simple <code>&lt;StackLayout&gt;</code> for stacking the UI elements on top of each other. In later sections, you&#39;ll use some of the more advanced layouts.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a stack layout to the login screen
</h4>

<p>Open <code>app/app.component.ts</code> and add a <code>&lt;StackLayout&gt;</code> element within your componentâ€™s <code>template</code> property. The full component should now look like this:</p>
<pre><code class="lang-JavaScript">@Component({
  selector: &quot;my-app&quot;,
  template: `
    &lt;StackLayout&gt;
      &lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot;
        autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
      &lt;TextField hint=&quot;Password&quot; secure=&quot;true&quot;&gt;&lt;/TextField&gt;

      &lt;Button text=&quot;Sign in&quot;&gt;&lt;/Button&gt;
      &lt;Button text=&quot;Sign up for Groceries&quot;&gt;&lt;/Button&gt;
    &lt;/StackLayout&gt;
  `
})
</code></pre>
<div class="exercise-end"></div>

<p>After your app updates with this change, you&#39;ll see that your login pageâ€™s UI elements stack up:</p>
<p><img src="images/chapter2/ios/2.png" alt="login 2">
<img src="images/chapter2/android/2.png" alt="login 2"></p>
<p>Although the UI elements are in the correct order, they could use some spacing and color to make the app look a bit nicer. To do that let&#39;s look at another NativeScript feature: CSS.</p>
<blockquote>
<p><strong>TIP</strong>:</p>
<ul>
<li>Refer to the NativeScript docs for <a href="http://docs.nativescript.org/layouts">a discussion on how NativeScript layouts work</a>, and the various attributes you can use to configure them.</li>
<li>Check out Jen Looper&#39;s article on <a href="https://www.nativescript.org/blog/demystifying-nativescript-layouts">demystifying NativeScript layouts</a> for a more thorough look at NativeScript layouts in action.</li>
</ul>
</blockquote>
<h3 id="global-css">Global CSS</h3>
<p>NativeScript uses a <a href="http://docs.nativescript.org/styling">subset of CSS</a> to change the visual appearance of your app. Why a subset? In NativeScript youâ€™re building native iOS and Android apps, and some CSS properties either arenâ€™t possible to replicate with native iOS and Android APIs, or would incur too great of a performance penalty. Donâ€™t worry though; most common CSS properties are supported, and the CSS language syntax is the sameâ€”so styling native apps in NativeScript really does feel like styling web apps.</p>
<blockquote>
<p><strong>TIP</strong>: The NativeScript docs have <a href="http://docs.nativescript.org/ui/styling#supported-properties">a full list of the supported CSS properties you can use</a>.</p>
</blockquote>
<p>You can use three mechanisms to add CSS properties to NativeScript UI components: <a href="http://docs.nativescript.org/styling#application-wide-css">application-wide CSS</a>, component-specific CSS, and an <a href="http://docs.nativescript.org/styling#inline-css">inline <code>style</code> attribute</a>. In this section weâ€™ll cover application-wide, or global CSS, and in the next section weâ€™ll look at how to apply CSS rules to individual components.</p>
<blockquote>
<p><strong>TIP</strong>: Although inline styles are great for quick testingâ€”e.g. <code>&lt;StackLayout style=&quot;background-color: green;&quot;&gt;</code>â€”you should avoid them in general because the <code>style</code> attributes tend to clutter up your templates, especially if you need to apply multiple rules.</p>
</blockquote>
<h4 class="exercise-start">
    <b>Exercise</b>: Create global styles
</h4>

<p>Open your <code>app/app.css</code> file and paste in the following code:</p>
<pre><code class="lang-CSS">Page {
  background-color: white;
  font-size: 15;
}
TextField {
  padding: 10;
  font-size: 13;
}
</code></pre>
<div class="exercise-end"></div>

<p>If you&#39;ve done any web development before, the syntax should feel familiar here. You select two UI components by their tag names (Page and TextField), and then apply a handful of CSS rules as name/value pairs.</p>
<blockquote>
<p><strong>NOTE</strong>: In NativeScript, a single <code>&lt;Page&gt;</code> UI element wraps the <code>template</code> of every page-level Angular component, which youâ€™ll learn about when we introduce routing later in this guide. For now, just know that a <code>&lt;Page&gt;</code> element exists as the parent of your <code>AppComponent</code>â€™s template, and that you can target that <code>&lt;Page&gt;</code> with CSS as you would with any other UI element.</p>
</blockquote>
<p>Although often you want CSS rules to apply equally to your iOS and Android app, occasionally it makes sense to apply a CSS rule to only one platform. For example, iOS text fields frequently have borders around them, but Android text fields do not. Let&#39;s look at how to make platform-specific style changes in NativeScript.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add platform-specific CSS
</h4>

<p>Add the following as the first line of your app&#39;s <code>app/app.css</code> file:</p>
<pre><code class="lang-CSS">@import url(&quot;~/platform.css&quot;);
</code></pre>
<blockquote>
<p><strong>WARNING</strong>: NativeScript is consistent with browser implementations in that <code>@import</code> statements must precede all other CSS rules in a file.</p>
</blockquote>
<p>Next, open your appâ€™s <code>app/platform.ios.css</code> file and paste in the following code:</p>
<pre><code class="lang-CSS">TextField {
  border-width: 1;
  border-color: black;
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: Weâ€™ll leave the <code>platform.android.css</code> file empty as we have no Android-specific changes to make yet.</p>
</blockquote>
<div class="exercise-end"></div>

<p>NativeScript supports CSS&#39;s <code>@import</code> statement for importing one CSS file into another. So this new line of code imports the CSS rules from <code>platform.css</code> into <code>app.css</code>. But, you might have noticed that Groceries does not have a file named <code>platform.css</code>â€”only <code>app/platform.android.css</code> and <code>app/platform.ios.css</code> exist. What&#39;s going on here?</p>
<p><a id="platform-specific-files"></a>When you execute <code>tns run</code>, or <code>tns livesync</code>, the NativeScript CLI takes the code from your <code>app</code> folder and places it in the native projects located in the <code>platforms/ios</code> and <code>platforms/android</code> folders. Here the naming convention comes in: while moving files, the CLI intelligently selects <code>.android.*</code> and <code>.ios.*</code> files. To give a specific example, the CLI moves <code>platform.ios.css</code> into <code>platforms/ios</code> and renames it to <code>platform.css</code>; similarly, the CLI moves <code>platform.android.css</code> into <code>platforms/android</code>, and again renames it to <code>platform.css</code>. This convention provides a convenient way to branch your code to handle iOS and Android separately, and it&#39;s supported for any type of file in NativeScriptâ€”not just CSS files. You&#39;ll see a few more examples of this convention later in this guide.</p>
<p>With these changes in place, you&#39;ll notice that the app has a bit more spacing, and also that the text fields have borders on iOS but that Android:</p>
<p><img src="images/chapter2/ios/3.png" alt="login 3">
<img src="images/chapter2/android/3.png" alt="login 3"></p>
<p>Despite our changes the app still looks pretty ugly, and thatâ€™s because weâ€™re going to apply another batch of styles at the component level. Letâ€™s look at how that works.</p>
<h3 id="component-specific-css">Component-specific CSS</h3>
<p>Much like on the web, sometimes in your NativeScript apps you want to write CSS rules that apply to your entire application, and sometimes you want to write CSS rules that apply to a specific portion of the interface. In the previous section you saw how to use NativeScriptâ€™s <code>app.css</code> file to write global rules, and in this section youâ€™ll learn how to use a componentâ€™s <code>styleUrls</code> property to apply rules that are scoped to individual components.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add component-specific CSS
</h4>

<p>Open your <code>app/app.component.ts</code> file and add a <code>styleUrls</code> property, so that that full <code>@Component</code> declaration now looks like this:</p>
<pre><code class="lang-JavaScript">@Component({
  selector: &quot;my-app&quot;,
  template: `
    &lt;StackLayout&gt;
      &lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot;
        autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
      &lt;TextField hint=&quot;Password&quot; secure=&quot;true&quot;&gt;&lt;/TextField&gt;

      &lt;Button text=&quot;Sign in&quot;&gt;&lt;/Button&gt;
      &lt;Button text=&quot;Sign up for Groceries&quot;&gt;&lt;/Button&gt;
    &lt;/StackLayout&gt;
  `,
  styleUrls: [&quot;pages/login/login-common.css&quot;, &quot;pages/login/login.css&quot;]
})
</code></pre>
<p>Next, open your appâ€™s <code>app/pages/login/login-common.css</code> file and paste in the following code:</p>
<pre><code class="lang-CSS">StackLayout {
  margin-left: 30;
  margin-right: 30;
  padding-bottom: 15;
  background-color: white;
}
Image {
  margin-top: 5;
  margin-bottom: 20;
}
Button, TextField {
  margin-left: 16;
  margin-right: 16;
  margin-bottom: 10;
}
.submit-button {
  background-color: #CB1D00;
  color: white;
  margin-top: 20;
}
</code></pre>
<div class="exercise-end"></div>

<p>In Angular 2, the <code>styleUrls</code> property points at an array of stylesheets that should be used to style a component. In this case, youâ€™re telling Angular to use two stylesheets, <code>login-common.css</code> and <code>login.css</code>â€”the latter of which is actually implemented as <code>login.ios.css</code> and <code>login.android.css</code>, using the same naming convention we introduced in the previous section.</p>
<p>Why three files? Much like you divided your global files into <code>app.css</code>, <code>platform.ios.css</code>, and <code>platform.android.css</code>, this structure gives you a similar ability to place common login styling in <code>login-common.css</code>, iOS-specific login styling <code>login.ios.css</code>, and Android-specific login styling in <code>login.android.css</code>.</p>
<p>The great thing about placing CSS rules at the component level is you can use concise CSS selectors such as <code>Button</code> and <code>TextField</code>, and not worry about those rules applying to all buttons and text fields in your application, as Angular 2 ensures those rules remain scoped to your component.</p>
<p>Before we see what your app looks like now, thereâ€™s one small change you need to make. Notice that the last selector used in <code>login-common.css</code> is <code>.submit-button</code>. Much like using CSS on the web, in NativeScript you can both <code>id</code> and <code>class</code> attributes to target specific user interface elements, but at the moment thereâ€™s no UI element in your app with an <code>class</code> of <code>&quot;submit-button&quot;</code>. Letâ€™s change that.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a <code>class</code> attribute
</h4>

<p>Open your <code>app/app.component.ts</code> file, find <code>&lt;Button text=&quot;Sign in&quot;&gt;&lt;/Button&gt;</code> in your componentâ€™s <code>template</code>, and replace it with the code below:</p>
<pre><code class="lang-XML">&lt;Button text=&quot;Sign in&quot; class=&quot;submit-button&quot;&gt;&lt;/Button&gt;
</code></pre>
<div class="exercise-end"></div>

<p>With this last <code>class</code> change in place your app is starting to look a little nicer:</p>
<p><img src="images/chapter2/ios/4.png" alt="login 4">
<img src="images/chapter2/android/4.png" alt="login 4"></p>
<p>As you can see, in NativeScript you have a lot of options for how you can apply CSS rules. You can apply rules globally either for both platforms in <code>app.css</code>, for iOS in <code>platform.ios.css</code>, or for Android in <code>platform.android.css</code>. And you can also apply rules at the component level, while maintaining the same flexibility to target different platforms if required.</p>
<p>To continue polishing the visuals of this login screen, letâ€™s look at how we can add an image of this appâ€™s logo.</p>
<h3 id="images">Images</h3>
<p>In NativeScript you use the <code>&lt;Image&gt;</code> UI element and its <code>src</code> attribute to add images to your pages. The <code>src</code> attribute lets you specify your image in three ways. The first (and simplest) way is to point at the URL of an image:</p>
<pre><code class="lang-XML">&lt;Image src=&quot;https://www.nativescript.org/images/default-source/landingpages/logo.png&quot;&gt;&lt;/Image&gt;
</code></pre>
<p>The second way is to point at an image that lives within your app&#39;s <code>app</code> folder. For example if you have an image at <code>app/images/logo.png</code>, you can use it with:</p>
<pre><code class="lang-XML">&lt;Image src=&quot;~/images/logo.png&quot;&gt;&lt;/Image&gt;
</code></pre>
<p>The third way, and the one Groceries uses, is to use platform-specific image resources. Let&#39;s add an image to the login screen and then discuss exactly what&#39;s happening.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a logo
</h4>

<p>In <code>app.component.ts</code>, add the <code>&lt;Image&gt;</code> below as the first child of the existing <code>&lt;StackLayout&gt;</code> tag:</p>
<pre><code class="lang-XML">&lt;Image src=&quot;res://logo_login&quot; stretch=&quot;none&quot; horizontalAlignment=&quot;center&quot;&gt;&lt;/Image&gt;
</code></pre>
<div class="exercise-end"></div>

<p>The <code>res://</code> syntax tells NativeScript to use a platform-specific resource, in this case an image. Platform-specific resources go in your app&#39;s <code>app/App_Resources</code> folder. If you look there you&#39;ll find a few different image files, several of which are named <code>logo_login.png</code>.</p>
<p>Although more complex than putting an image directly in the <code>app</code> folder, using platform-specific images gives you more control over image display on different device dimensions. For example iOS lets you provide three different image files for devices with different pixel densities. As such you&#39;ll find logos named <code>logo_login.png</code>, <code>logo_login@2x.png</code>, and <code>logo_login@3x.png</code> in your <code>App_Resources/iOS</code> folder. For Android you&#39;ll find similar image files in <code>App_Resources/Android/drawable-hdpi</code> (for &quot;high&quot; dpi, or high dots-per-inch), <code>App_Resources/Android/drawable-mdpi</code> (for medium-dpi), and <code>App_Resources/Android/drawable-ldpi</code> (for low-dpi).</p>
<p>Once these files are in place the NativeScript framework knows how to pick the correct file; all you have to do is reference the image using <code>res://</code> and its base file nameâ€”i.e. <code>res://logo_login</code>. Here&#39;s what your login screen should look like on iOS and Android:</p>
<p><img src="images/chapter2/ios/5.png" alt="login 5">
<img src="images/chapter2/android/5.png" alt="login 5"></p>
<p>At this point your UI looks better visually, but the app still doesn&#39;t actually do anything. Let&#39;s look at how you can use JavaScript to add some functionality.</p>
<blockquote>
<p><strong>TIP</strong>: The community-written <a href="http://nsimage.brosteins.com/">NativeScript Image Builder</a> can help you generate images with the appropriate naming conventions and resolutions for iOS and Android.</p>
</blockquote>

			</div>
			<div class="chapter">
				<h2 id="application-logic">Application Logic</h2>
<p>In this chapter youâ€™ll learn how to add TypeScript logic to your app, how to create services that talk to backend endpoints, and how to architect an app to share code with Angular 2 web apps. Thereâ€™s a lot to cover, so letâ€™s start by discussing how to handle events and data binding.</p>
<h3 id="events">Events</h3>
<p>Most user interfaces are driven by events. In NativeScript apps, those events are usually some user action, such as tapping, swiping, or rotatingâ€”and NativeScript abstracts the iOS- and Android-specific code for handling such events into a handful of easy-to-use APIs. Letâ€™s start with the most common event youâ€™ll use in a NativeScript app: <code>tap</code>.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a <code>tap</code> event handler
</h4>

<p>Open <code>app/app.component.ts</code>, find the existing sign in button within your componentâ€™s <code>template</code> (<code>&lt;Button text=&quot;Sign in&quot;&gt;&lt;/Button&gt;</code>), and replace it with the following code:</p>
<pre><code class="lang-TypeScript">&lt;Button text=&quot;Sign in&quot; class=&quot;submit-button&quot; (tap)=&quot;submit()&quot;&gt;&lt;/Button&gt;
</code></pre>
<p>Next, in the same file, replace the current <code>AppComponent</code> declaration with the one shown below:</p>
<pre><code class="lang-TypeScript">export class AppComponent {
  submit() {
    console.log(&quot;hello&quot;);
  }
}
</code></pre>
<div class="exercise-end"></div>

<p>The <code>(eventName)=&quot;functionName()&quot;</code> syntax is part of <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#!#event-binding">Angular 2â€™s event binding system</a>, which lets you bind an event that occurs on a UI element to a function in your componentâ€™s class. In this case, the <code>(tap)=&quot;submit()&quot;</code> syntax tells Angular to run the <code>AppComponent</code> classâ€™s <code>submit()</code> function whenever the user taps the sign in button.</p>
<p>To verify this binding works tap the â€œSign Inâ€ button in your app; you should see â€œhelloâ€ logged in your terminal or command prompt as such:</p>
<p><img alt="Terminal showing the word hello logged" src="images/chapter3/terminal-1.png" class="plain"></p>
<blockquote>
<p><strong>TIP</strong>:</p>
<ul>
<li>You can find a list of events available for each UI element on its API documentation page. For instance, the <a href="http://docs.nativescript.org/ApiReference/ui/button/Button">button elementâ€™s API documentation</a> lists its <code>tap</code> event.</li>
<li>The Angular 2 docs have a helpful <a href="https://angular.io/docs/ts/latest/guide/cheatsheet.html">cheat sheet</a> that includes the various syntaxes available when building templates. Donâ€™t worry too much about knowing how all these work at the moment; weâ€™ll progressively introduce the most common syntaxes in this guide.</li>
</ul>
</blockquote>
<p>With the <code>tap</code> event in place, you now have a way of tying the UI elements in your template to your TypeScript code. To make a login page actually work though, we need to introduce one other way of connecting a template to code: data binding.</p>
<h3 id="data-binding">Data Binding</h3>
<p>Angular 2 provides several ways to bind data in your TypeScript code to UI controls, and through the magic of NativeScript those same methods are available in your iOS and Android apps.</p>
<p>The first of these is a way to bind UI attributes to properties defined in your TypeScript class. Letâ€™s look at how it works.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Using Angular 2 attribute binding
</h4>

<p>In <code>app/app.component.ts</code> replace the current <code>AppComponent</code> declaration with the one shown below, which adds a new <code>email</code> property, and changes the <code>submit()</code> method to display its value:</p>
<pre><code class="lang-TypeScript">export class AppComponent {
  email = &quot;nativescriptrocks@telerik.com&quot;;
  submit() {
    alert(&quot;Youâ€™re using: &quot; + this.email);
  }
}
</code></pre>
<p>Next, find the first <code>&lt;TextField&gt;</code> in your componentâ€™s <code>template</code> and replace it with the code below, which adds a new <code>text</code> attribute:</p>
<pre><code class="lang-XML">&lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; [text]=&quot;email&quot;
  autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
</code></pre>
<div class="exercise-end"></div>

<p>The key thing to note here is the <code>[text]=&quot;email&quot;</code> attribute on the <code>&lt;TextField&gt;</code>. This is Angular 2â€™s syntax for attribute binding, and it allows you to bind the value of an attribute to a property in your TypeScript class. In this case, the <code>text</code> attribute of the <code>&lt;TextField&gt;</code>â€”which is roughly equivalent to a DOM <code>&lt;input&gt;</code>â€™s <code>value</code> attributeâ€”is bound to the <code>AppComponent</code>â€™s <code>email</code> attribute. Therefore the app now has an email address prefilled when it loads:</p>
<p><img src="images/chapter3/android/1.png" alt="Android with prefilled email">
<img src="images/chapter3/ios/1.png" alt="iOS with prefilled email"></p>
<blockquote>
<p><strong>NOTE</strong>: Itâ€™s very easy to confuse Angular 2â€™s event binding syntax <code>(eventName)=&quot;functionName()&quot;</code> with its attribute binding syntax <code>[attributeName]=&quot;propertyName&quot;</code>. Donâ€™t worry though; if you get them backwards, the problem is usually easy to debug, as the functionality youâ€™re attempting to add just wonâ€™t work. These syntaxes are common enough that youâ€™ll be using them a lot, and eventually you should be able to commit them to memory.</p>
</blockquote>
<p>This attribute binding approach works really well when you need the data binding to be one wayâ€”that is, when you need TypeScript properties, and changes to those properties done in TypeScript code, to appear in the user interface. But in the case of user interface controls that accept user input, such as the text field in this example, usually you need data binding to work two wayâ€”that is, you additionally need changes the user makes to data via form controls to be reflected in your TypeScript code.</p>
<p>To show that the current exampleâ€™s data binding is only one way, head back to your app, change the email text fieldâ€™s value (type a few extra letters or something like that), and then tap the â€œSign Inâ€ button. Because your <code>submit()</code> function alerts the current value of your componentâ€™s <code>email</code> propertyâ€”<code>alert(&quot;Youâ€™re using: &quot; + this.email)</code>â€”you might expect to see the updated value in the alert. Instead, however, you see the original value. Notice how the typed text and the alert value donâ€™t match in the screenshot below.</p>
<p><img src="images/chapter3/android/2.png" alt="Android with email address that do not match"></p>
<p>To fix this, you need to switch to Angular 2â€™s two-way data binding syntax.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Two-way data binding with Angular 2
</h4>

<p>In <code>app/app.component.ts</code>, find the first <code>&lt;TextField&gt;</code>, and replace it with the <code>&lt;TextField&gt;</code> below, which introduces a new <code>[(ngModel)]</code> attribute:</p>
<pre><code class="lang-XML">&lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; [(ngModel)]=&quot;email&quot;
  autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
</code></pre>
<div class="exercise-end"></div>

<p>At first glance the <code>[(ngModel)]</code> syntax looks more than a little odd, as itâ€™s essentially a combination of the event and attribute binding syntax that you used in earlier examples. In the case of this example, <code>[(ngModel)]=&quot;email&quot;</code> is shorthand for <code>[text]=&quot;email&quot; (emailChange)=&quot;email=$event&quot;</code>, which binds the email elementâ€™s <code>text</code> attribute to an <code>email</code> property and adds a <code>change</code> event handler that updates the <code>email</code> propertyâ€™s value whenever the user makes a change.</p>
<p>Donâ€™t worry too much about the details of this syntax while youâ€™re getting started. In your head you can think of <code>[(ngModel)]</code> as the way to implement two-way data binding when you need it on form controls. To show that it works, if you again modify your appâ€™s email address and click the â€œSign Inâ€ button, youâ€™ll see the updated value in the alert as expected:</p>
<p><img src="images/chapter3/android/3.png" alt="Android with email addresses that do match"></p>
<p>Before we move on, letâ€™s make one additional change to show what else you can do with Angular 2â€™s data binding APIs. The Groceries app uses the same UI for the â€œSign Inâ€ form and the â€œSign Upâ€ form. Therefore, when the user taps â€œSign Upâ€, we need to update the text of the buttons (and eventually the functionality that occurs when you tap them). Letâ€™s see how to make that happen.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Using the ternary operator in templates
</h4>

<p>Open <code>app/app.component.ts</code> and replace the two existing buttons with the code below:</p>
<pre><code class="lang-XML">&lt;Button [text]=&quot;isLoggingIn ? &#39;Sign in&#39; : &#39;Sign up&#39;&quot; class=&quot;submit-button&quot; (tap)=&quot;submit()&quot;&gt;&lt;/Button&gt;
&lt;Button [text]=&quot;isLoggingIn ? &#39;Sign up&#39; : &#39;Back to login&#39;&quot; (tap)=&quot;toggleDisplay()&quot;&gt;&lt;/Button&gt;
</code></pre>
<p>Next, replace the existing <code>AppComponent</code> declaration with the code below, which adds a new <code>isLoggingIn</code> property, and a new <code>toggleDisplay()</code> method:</p>
<pre><code class="lang-TypeScript">export class AppComponent {
  email = &quot;nativescriptrocks@telerik.com&quot;;
  isLoggingIn = true;

  submit() {
    alert(&quot;Youâ€™re using: &quot; + this.email);
  }
  toggleDisplay() {
    this.isLoggingIn = !this.isLoggingIn;
  }
}
</code></pre>
<div class="exercise-end"></div>

<p>The previous examples switches each buttonâ€™s <code>text</code> attribute from a simple stringâ€”e.g. <code>&lt;Button text=&quot;Sign Up&quot;&gt;</code>â€”to an attribute binding that is dependent on a value defined in the <code>AppComponent</code> classâ€”e.g. <code>&lt;Button [text]=&quot;isLoggingIn ? &#39;Sign in&#39; : &#39;Sign up&#39;&quot;&gt;&quot;</code>. Now, when the value of the <code>isLoggingIn</code> attributes changes after the user taps the bottom button, Angular is smart enough to update the text of the button automatically. The result looks like this:</p>
<p><img src="images/chapter3/android/4.gif" alt="Text changing on Android">
<img src="images/chapter3/ios/4.gif" alt="Text changing on iOS"></p>
<p>At this point, you have a basic login screen setup with two-way data bindingâ€”which isnâ€™t bad for 20 some lines of TypeScript. (Think about how much code youâ€™d have to write in Android Studio <em>and</em> Xcode to accomplish the same task.) To this point though youâ€™ve been placing all of your logic in a single TypeScript file, which doesnâ€™t scale all that well for real-world applications.</p>
<p>Before we tie this app to a backend and make this login screen fully functional, letâ€™s take a step back and setup a structure that can scale.</p>
<h3 id="structuring-your-app">Structuring your app</h3>
<p>There are many reasons to segment any application into modular units, and you can <a href="https://en.wikipedia.org/wiki/Modular_programming">read about the various benefits on Wikipedia</a>. Modularizing NativeScript has one additional, unique benefit: the ability to share the code you write between Angular-2-built web apps, and Angular-2-built native apps.</p>
<p>Even if you have no plans to create an Angular 2 web app, separating out your code is still advantageous for a number of other reasonsâ€”testability, ease of maintenance, and so forthâ€”but if you <em>do</em> have plans to build an Angular 2 web app, having a chunk of functionality that you can reuse in your native and web apps can be an invaluable time saver.</p>
<blockquote>
<p><strong>NOTE</strong>: To show that sharing code between native and web projects is possible, and not theoretical, feel free to peruse <a href="https://github.com/tjvantoll/Groceries">our web implementation of Groceries</a>, which uses the exact same <code>shared</code> folder this guideâ€™s native implementation does.</p>
</blockquote>
<p>To see how this works in action, letâ€™s edit some files in the <code>shared</code> folder and set them up to be imported.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a model object
</h4>

<p>Letâ€™s start by creating a simple model object to store user data. Open <code>app/shared/user/user.ts</code> and paste in the following code:</p>
<pre><code class="lang-TypeScript">export class User {
  email: string;
  password: string;
}
</code></pre>
<p>This code defines a simple <a href="http://www.typescriptlang.org/Handbook#classes">TypeScript class</a> that does nothing more than define two propertiesâ€”<code>email</code> and <code>password</code>. Note the use of <a href="http://www.typescriptlang.org/Handbook#modules-going-external">TypeScriptâ€™s <code>export</code> keyword</a>, as weâ€™ll see why thatâ€™s important momentarily.</p>
<p>Next, open <code>app/app.component.ts</code>, and add the following <code>import</code> to the top of the file:</p>
<pre><code class="lang-TypeScript">import {User} from &quot;./shared/user/user&quot;;
</code></pre>
<p>Here you import the <code>User</code> class that you just defined. Note the parallel between the <code>export</code> command used in the previous example and the <code>import</code> command used here. The reason the <code>User</code> class is available to import is because it was explicitly exported. Youâ€™ll see other examples of <code>import</code> and <code>export</code> as you go through this guide.</p>
<p>Next, replace the existing <code>AppComponent</code> definition with the one below, which uses the <code>User</code> class you just imported.</p>
<pre><code class="lang-TypeScript">export class AppComponent {
  user: User;
  isLoggingIn = true;

  constructor() {
    this.user = new User();
  }
  submit() {
    alert(&quot;Youâ€™re using: &quot; + this.user.email);
  }
  toggleDisplay() {
    this.isLoggingIn = !this.isLoggingIn;
  }
}
</code></pre>
<p>Instead of storing data on the <code>AppComponent</code> directly, youâ€™re now using the <code>User</code> model object, which is reusable outside of this page and even outside of this application. You instantiate an instance of the <code>User</code> class in a new <code>constructor</code> function, which Angular 2 invokes when it bootstraps your application.</p>
<p>Your next step is to use this new model object in your template. To do that, replace the two existing <code>&lt;TextField&gt;</code>s with the code shown below, which updates the <code>[(ngModel)]</code> bindings to point at the new <code>User</code> object:</p>
<pre><code class="lang-XML">&lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; [(ngModel)]=&quot;user.email&quot;
  autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
&lt;TextField hint=&quot;Password&quot; secure=&quot;true&quot; [(ngModel)]=&quot;user.password&quot;&gt;&lt;/TextField&gt;
</code></pre>
<p>As one final change, because this template is getting to be a bit complex, letâ€™s move it into a separate file. Open <code>app/pages/login/login.html</code> and paste in the following code:</p>
<pre><code class="lang-XML">&lt;StackLayout&gt;
  &lt;Image src=&quot;res://logo_login&quot; stretch=&quot;none&quot; horizontalAlignment=&quot;center&quot;&gt;&lt;/Image&gt;

  &lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; [(ngModel)]=&quot;user.email&quot;
    autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
  &lt;TextField hint=&quot;Password&quot; secure=&quot;true&quot; [(ngModel)]=&quot;user.password&quot;&gt;&lt;/TextField&gt;

  &lt;Button [text]=&quot;isLoggingIn ? &#39;Sign in&#39; : &#39;Sign up&#39;&quot; class=&quot;submit-button&quot; (tap)=&quot;submit()&quot;&gt;&lt;/Button&gt;
  &lt;Button [text]=&quot;isLoggingIn ? &#39;Sign up&#39; : &#39;Back to login&#39;&quot; (tap)=&quot;toggleDisplay()&quot;&gt;&lt;/Button&gt;
&lt;/StackLayout&gt;
</code></pre>
<p>Finally, in <code>app/app.component.ts</code>, replace the existing <code>template</code> property with the new <code>templateUrl</code> property shown below:</p>
<pre><code class="lang-TypeScript">templateUrl: &quot;pages/login/login.html&quot;
</code></pre>
<p>In case you got lost during this section, hereâ€™s a copy-and-paste friendly of the <code>app/app.component.ts</code> file you should have at this point:</p>
<pre><code class="lang-TypeScript">import {Component} from &quot;angular2/core&quot;;
import {User} from &quot;./shared/user/user&quot;;

@Component({
  selector: &quot;my-app&quot;,
  templateUrl: &quot;pages/login/login.html&quot;,
  styleUrls: [&quot;pages/login/login-common.css&quot;, &quot;pages/login/login.css&quot;]
})
export class AppComponent {
  user: User;
  isLoggingIn = true;

  constructor() {
    this.user = new User();
  }
  submit() {
    alert(&quot;Youâ€™re using: &quot; + this.user.email);
  }
  toggleDisplay() {
    this.isLoggingIn = !this.isLoggingIn;
  }
}
</code></pre>
<div class="exercise-end"></div>

<blockquote>
<p><strong>TIP</strong>:</p>
<ul>
<li>With Angular 2 components you have the ability to specify templates and CSS styling in two placesâ€”directly within the component, or in external files. For simple components feel free to choose either approach based on your personal preference, but once your templates/styles get to ~10 lines of code, consider using external files exclusively, as mixing non-trivial UI, CSS, and TypeScript code makes your component code less readable.</li>
<li>Youâ€™re free to provide any suffix for your NativeScript template file names. This guide uses <code>.html</code> suffixes, even though NativeScript templates arenâ€™t HTML code, because that suffix tends to provide the best syntax highlighting in common development IDEs. This guide does <em>not</em> use <code>.xml</code> suffixes because Angular 2 syntaxes like <code>(tap)</code> and <code>[text]</code> are not valid XML.</li>
</ul>
</blockquote>
<p>With this setup you now have a <code>User</code> class that you can share across pages in your app and even across applications. But a model object thatâ€™s four simple lines of code isnâ€™t all that exciting. Where this approach really pays off is when youâ€™re able to share your business logic, and the code that hits your backend systems. In Angular 2 those classes are known as services. Letâ€™s look at them next.</p>
<h3 id="services">Services</h3>
<p>A login screen isnâ€™t all that useful if it doesnâ€™t actually log users into anything. Therefore, our next task is to allow users to create and log into accounts. Weâ€™ll build this functionality as an <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt4.html">Angular 2 service</a>, which is Angular 2â€™s mechanism for reusable classes that operate on data.</p>
<p>For the purposes of this tutorial we prebuilt a handful of backend endpoints using <a href="http://www.telerik.com/platform/backend-services">Telerik Backend Services</a>, and weâ€™ll be using those endpoints to make this app functional. Letâ€™s see how they work.</p>
<blockquote>
<p><strong>NOTE</strong>: You don&#39;t have to use Telerik Backend Services to power your appâ€™s backend; you can use any HTTP API in a NativeScript app, including common solutions such as <a href="http://plugins.telerik.com/nativescript/plugin/firebase">Firebase</a> and <a href="https://github.com/couchbaselabs/nativescript-couchbase">Couchbase</a>. Telerik Backend Services is convenient for us to use for this tutorial because it lets us spin up HTTP endpoints quickly.</p>
</blockquote>
<h4 class="exercise-start">
    <b>Exercise</b>: Add an Angular 2 service
</h4>

<p>There are several new concepts to introduce with Angular services, so weâ€™re going to start by stubbing out a new <code>register()</code> method, and then come back to the implementation later in this section. With that in mind, open <code>app/shared/user/user.service.ts</code> and paste in the following code:</p>
<pre><code class="lang-TypeScript">import {Injectable} from &quot;angular2/core&quot;;
import {User} from &quot;./user&quot;;

@Injectable()
export class UserService {
  register(user: User) {
    alert(&quot;About to register: &quot; + user.email);
  }
}
</code></pre>
<p>This creates a basic Angular service with a single method that takes an instance of the <code>User</code> object you created in the previous section. The one new thing is the <code>@Injectable</code> decorator. This decorator denotes this class as a candidate for <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">Angularâ€™s dependency injection mechanism</a>. For now just think of adding the <code>@Injectable</code> as a required convention for all services that you write.</p>
<p>Next, add the following line to the top of <code>app/app.component.ts</code>, which imports the service you just defined:</p>
<pre><code class="lang-TypeScript">import {UserService} from &quot;./shared/user/user.service&quot;;
</code></pre>
<p>After that, add a new <code>providers</code> property to the existing <code>@Component</code> decorator. The full <code>@Component</code> declaration should now look like this:</p>
<pre><code class="lang-TypeScript">@Component({
  selector: &quot;my-app&quot;,
  providers: [UserService],
  templateUrl: &quot;pages/login/login.html&quot;,
  styleUrls: [&quot;pages/login/login-common.css&quot;, &quot;pages/login/login.css&quot;],
})
</code></pre>
<p>The <code>providers</code> array is a simple list of all the Angular 2 services that you need to use in your component. At the moment you only have one service, so your <code>providers</code> array only has one entry.</p>
<p>Next, replace <code>AppComponent</code>â€™s existing <code>constructor</code> with the code below:</p>
<pre><code class="lang-TypeScript">constructor(private _userService: UserService) {
  this.user = new User();
}
</code></pre>
<p>Weâ€™ll discuss what this <code>constructor</code> syntax is doing momentarily, as it can be confusing if youâ€™ve never worked with Angular 2 before, but first letâ€™s make the final change to get this example running. Find the existing <code>submit()</code> function in <code>AppComponent</code>, and replace it with the following three functions:</p>
<pre><code class="lang-TypeScript">submit() {
  if (this.isLoggingIn) {
    this.login();
  } else {
    this.signUp();
  }
}
login() {
  // TODO: Define
}
signUp() {
  this._userService.register(this.user);
}
</code></pre>
<div class="exercise-end"></div>

<p>Now, in your app, tap the â€œSign Upâ€ button, type an email address, and tap the â€œSign Upâ€ button again. If all went well, you should see the alert below:</p>
<p><img src="images/chapter3/android/5.png" alt="Alert on Android">
<img src="images/chapter3/ios/5.png" alt="Alert on iOS"></p>
<p>How does this code work? Letâ€™s return to this bit of code:</p>
<pre><code class="lang-TypeScript">constructor(private _userService: UserService) {
  this.user = new User();
}
</code></pre>
<p>This is Angular 2â€™s dependency injection implementation in action. Because you registered <code>UserService</code> as a provider in this componentâ€™s <code>providers</code> array, when Angular sees this syntax it creates an instance of the <code>UserService</code> class, and passes that instance into the componentâ€™s constructor.</p>
<p>This begs a bigger question though: why bother with all of this? Why not run <code>this._userService = new UserService()</code> in the componentâ€™s constructor and forget the complexity of <code>@Injectable</code> and <code>providers</code>?</p>
<p>The short answer is a dependency-injection-based approach to coding keeps your classes less coupled, and therefore more maintainable and testable as your application evolves over time. For a longer answer, head over to the Angularâ€™s docs for a <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">thorough discussion of the benefits of dependency injection</a>.</p>
<blockquote>
<p><strong>NOTE</strong>: If youâ€™re looking to learn more about Angular 2â€™s <code>providers</code> array and dependency injection implementation, the <a href="http://blog.thoughtram.io/">thoughtram blog</a> has a great 3-part series that covers the topic in more detail than this guide.</p>
<ul>
<li><a href="http://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html">Part 1â€”Dependency Injection</a></li>
<li><a href="http://blog.thoughtram.io/angular/2015/08/20/host-and-visibility-in-angular-2-dependency-injection.html">Part 2â€”Host and Visibility</a></li>
<li><a href="http://blog.thoughtram.io/angular2/2015/11/23/multi-providers-in-angular-2.html">Part 3â€”Multi Providers</a></li>
</ul>
</blockquote>
<p>Letâ€™s return to our example and make the registration process actually work.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Use an Angular 2 service
</h4>

<p>Open <code>app/shared/user/user.service.ts</code> and paste in the following code, which weâ€™ll discuss in detail in a moment.</p>
<pre><code class="lang-TypeScript">import {Injectable} from &quot;angular2/core&quot;;
import {Http, Headers, Response} from &quot;angular2/http&quot;;
import {User} from &quot;./user&quot;;
import {Config} from &quot;../config&quot;;
import {Observable} from &quot;rxjs/Rx&quot;;
import &quot;rxjs/add/operator/do&quot;;
import &quot;rxjs/add/operator/map&quot;;

@Injectable()
export class UserService {
  constructor(private _http: Http) {}

  register(user: User) {
    let headers = new Headers();
    headers.append(&quot;Content-Type&quot;, &quot;application/json&quot;);

    return this._http.post(
      Config.apiUrl + &quot;Users&quot;,
      JSON.stringify({
        Username: user.email,
        Email: user.email,
        Password: user.password
      }),
      { headers: headers }
    )
    .catch(this.handleErrors);
  }

  handleErrors(error: Response) {
    console.log(JSON.stringify(error.json()));
    return Observable.throw(error);
  }
}
</code></pre>
<p>Next, in <code>app/app.component.ts</code>, replace the existing <code>signUp()</code> function with the following code:</p>
<pre><code class="lang-TypeScript">signUp() {
  this._userService.register(this.user)
    .subscribe(
      () =&gt; {
        alert(&quot;Your account was successfully created.&quot;);
        this.toggleDisplay();
      },
      () =&gt; alert(&quot;Unfortunately we were unable to create your account.&quot;)
    );
}
</code></pre>
<div class="exercise-end"></div>

<p>The first thing to note here is the new <code>constructor</code> code in <code>user.service.ts</code>:</p>
<pre><code class="lang-TypeScript">constructor(private _http: Http) {}
</code></pre>
<p>The <code>UserService</code> class is using the same dependency injection technique to bring in a service that it needs, in this case the Http class, which is Angular 2â€™s way of letting you perform HTTP calls. And thanks to NativeScript, those same HTTP APIs work on iOS and Android without any extra work.</p>
<blockquote>
<p><strong>TIP</strong>: Refer to <a href="https://angular.io/docs/ts/latest/api/http/Http-class.html">Angular 2â€™s docs on Http</a> for specifics on what HTTP APIs are available.</p>
</blockquote>
<p>The other new bit of code is the return value of this new <code>register()</code> method. <code>register()</code> returns <code>this._http.post()</code>, which is an RxJS <code>Observable</code>. You can refer to the Angular docs for a <a href="https://angular.io/docs/ts/latest/guide/server-communication.html">full tutorial on how RxJS observables work</a>, but for now just know that the most common thing youâ€™ll need to do with observables is subscribe to them, which is what the new code you added to <code>app.component.ts</code> does:</p>
<pre><code class="lang-TypeScript">this._userService.register(this.user)
  .subscribe(
    () =&gt; {
      alert(&quot;Your account was successfully created.&quot;);
      this.toggleDisplay();
    },
    () =&gt; alert(&quot;Unfortunately we were unable to create your account.&quot;)
  );
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: The <code>() =&gt; {}</code> syntax defines an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">ES2015 arrow function</a>, which TypeScript supports out of the box. In this example, the arrow functions are the equivalent of writing <code>function() {}</code>. Arrow functions have the advantage of inheriting their contextâ€”aka <code>this</code>â€”from their parents. Note how the code above is able to call <code>this.toggleDisplay()</code> from an inner function, which would not work with a generic JavaScript <code>function() {}</code>.</p>
</blockquote>
<p>The two functions you pass <code>subscribe()</code> are success and failure handlers. If the call to <code>register()</code> succeeds, your first alert will fire, and if the call to <code>register()</code> fails, your second alert will fire. Now that your service code is setup and ready to go, letâ€™s create make the final few changes and create an account.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create an account
</h4>

<p>Because the <code>UserService</code> makes use of the <code>Http</code> service, your final step is registering the Http provider in <code>AppComponent</code>. Start by opening <code>app/app.component.ts</code> and adding the following import to the top of the file:</p>
<pre><code class="lang-TypeScript">import {HTTP_PROVIDERS} from &quot;angular2/http&quot;;
</code></pre>
<p>Next, in the same file, replace the current <code>providers</code> array with the following code:</p>
<pre><code class="lang-TypeScript">providers: [UserService, HTTP_PROVIDERS],
</code></pre>
<p><a href="https://angular.io/docs/ts/latest/api/http/HTTP_PROVIDERS-let.html"><code>HTTP_PROVIDERS</code></a> is an Angular-provided shorthand array that includes all of Angularâ€™s HTTP-based services, including the <code>Http</code> service that <code>UserService</code> uses.</p>
<blockquote>
<p><strong>NOTE</strong>: Angular supports the concept of <a href="https://angular.io/docs/ts/latest/guide/hierarchical-dependency-injection.html">hierarchical dependency injectors</a>, which is a fancy way of saying that you can declare <code>providers</code> in parent components. In this example, this concept means you can declare <code>HTTP_PROVIDERS</code> in <code>AppComponent</code>, even though the <code>Http</code> service is used in <code>UserService</code>. Weâ€™ll discuss best practices around where to declare <code>providers</code> for services later in this guide.</p>
</blockquote>
<p>At this point you should be ready to create an account to verify this whole setup worked. After the provider changes have livesyncâ€™d, perform the following tasks to create an account:</p>
<ul>
<li>1) Click the gray â€œSign Upâ€ button in your app.</li>
<li>2) Type in an email address and password. Fake credentials are fine, just make up something you can remember.</li>
<li>3) Click the orange â€œSign Upâ€ button.</li>
</ul>
<div class="exercise-end"></div>

<p>If all went well, you should see a confirmation dialog that looks like this:</p>
<p><img src="images/chapter3/android/6.png" alt="Alert on Android">
<img src="images/chapter3/ios/6.png" alt="Alert on iOS"></p>
<blockquote>
<p><strong>TIP</strong>:  After creating your account, you may wish to hardcode your credentials in your <code>AppComponent</code>â€™s <code>constructor()</code> to make development faster for the rest of this guide.</p>
<pre><code class="lang-TypeScript">constructor(private _userService: UserService) {
  this.user = new User();
  this.user.email = &quot;user@nativescript.org&quot;;
  this.user.password = &quot;password&quot;;
}
</code></pre>
</blockquote>
<p>Your app now has a fully functional registration process, but users canâ€™t do anything with the accounts they create. Our next step is to allow the users to login and navigate to a new list page. And to do that we need to introduce the concept of routing.</p>
<h3 id="routing">Routing</h3>
<p>Most of the Angular 2 concepts youâ€™ve used in the last few sections are the same regardless of whether youâ€™re building for the web or native apps. You are even able to share model objects and services directly between the two environments.</p>
<p>However, routing is a bit different, as there are some fundamental differences between how the concept of routing works on the web and in apps. Routing on the web revolves around the concept of a URL, but in a native app there is no browser. Likewise, native apps have concepts that arenâ€™t present in the browser, such as Androidâ€™s hardware back button, or iOSâ€™s swipe left-to-right gesture to go back.</p>
<p>Because of that, even though NativeScript uses the same Angular 2 routing APIs, you must designate certain Angular components in your app as â€œpagesâ€â€”which is something you donâ€™t necessarily have to do in an Angular 2 web app. In Groceries the code for these pages is in the appâ€™s <code>pages</code> folder. Letâ€™s look at this works in an exercise, and then step back and discuss why NativeScript takes the approach that it does.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Setting up routing
</h4>

<p>To this point youâ€™ve been putting your login page code in <code>app.component.ts</code>. Letâ€™s move that logic into the <code>pages/login</code> folder to make room for additional pages.</p>
<p>First, open <code>app/app.component.ts</code> and copy its contents into <code>app/pages/login/login.component.ts</code>.</p>
<p>Next, in <code>login.component.ts</code>, change the name of the class from â€œAppComponentâ€ to â€œLoginPageâ€, and update the two paths below accordingly:</p>
<pre><code class="lang-TypeScript">import {User} from &quot;../../shared/user/user&quot;;
import {UserService} from &quot;../../shared/user/user.service&quot;;
</code></pre>
<p>Now that <code>app.component.ts</code> is empty, letâ€™s add in the appropriate Angular 2 routing code. Open <code>app/app.component.ts</code> back up and paste in the following code:</p>
<pre><code class="lang-TypeScript">import {Component} from &quot;angular2/core&quot;;
import {RouteConfig} from &quot;angular2/router&quot;;
import {NS_ROUTER_DIRECTIVES, NS_ROUTER_PROVIDERS} from &quot;nativescript-angular/router&quot;;
import {LoginPage} from &quot;./pages/login/login.component&quot;;

@Component({
  selector: &quot;main&quot;,
  directives: [NS_ROUTER_DIRECTIVES],
  providers: [NS_ROUTER_PROVIDERS],
  template: &quot;&lt;page-router-outlet&gt;&lt;/page-router-outlet&gt;&quot;
})
@RouteConfig([
  { path: &quot;/Login&quot;, component: LoginPage, name: &quot;Login&quot;, useAsDefault: true },
])
export class AppComponent {}
</code></pre>
<div class="exercise-end"></div>

<p>If you havenâ€™t played with routing in Angular 2 before, you can refer to <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt5.html">Angularâ€™s tutorial on the topic</a> for some background, but the basic concept is you include a  <code>@RouteConfig</code> decorator, and pass that decorator a list of all routes that are present in your app. Currently you only have one route, which is why <code>@RouteConfig</code> contains a single entry.</p>
<p>The other new concept in this example is the <code>&lt;page-router-outlet&gt;</code> tag, which is your appâ€™s first directive. You can again check out Angularâ€™s docs if you want <a href="https://angular.io/docs/ts/latest/api/core/Directive-decorator.html">detailed information on what directives are and do</a>, but the simplest way to think of a directive is as something that can affect the markup you put in your <code>template</code>â€”in this case <code>&lt;page-router-outlet&gt;</code>.</p>
<p>And to take a step back, that directive, <code>&lt;page-router-outlet&gt;</code> is the only difference in routing between the routing code above and the <a href="https://github.com/tjvantoll/Groceries/blob/master/app/app.component.ts">same code in the Groceries web implementation</a>. Angular 2 provides a <code>&lt;router-outlet&gt;</code> directive for web apps, and NativeScript extends that directive with its own <code>&lt;page-router-outlet&gt;</code> directive that handles the unique environment of iOS and Android apps. The great thing about NativeScript is those details are transparent to you as a developer.</p>
<p>Letâ€™s add another page to see the routing in action.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create the list page
</h4>

<p>Open <code>pages/list/list.component.ts</code> and paste in the following code, which youâ€™ll use as the start of a simple list page:</p>
<pre><code class="lang-TypeScript">import {Component} from &quot;angular2/core&quot;;

@Component({
  selector: &quot;list&quot;,
  templateUrl: &quot;pages/list/list.html&quot;,
  styleUrls: [&quot;pages/list/list-common.css&quot;, &quot;pages/list/list.css&quot;]
})
export class ListPage {}
</code></pre>
<p>For now, weâ€™ll keep the list page simple so you can see how the routing works. But so that thereâ€™s something to see, open <code>pages/list/list.html</code> and paste the following label:</p>
<pre><code class="lang-XML">&lt;Label text=&quot;Hello world&quot;&gt;&lt;/Label&gt;
</code></pre>
<p>After that, go back to <code>app/app.component.ts</code> and paste the following import in at the top of the file:</p>
<pre><code class="lang-TypeScript">import {ListPage} from &quot;./pages/list/list.component&quot;;
</code></pre>
<p>Next, replace the existing <code>@RouteConfig</code> with the following code so that it includes this new list page:</p>
<pre><code class="lang-TypeScript">@RouteConfig([
  { path: &quot;/Login&quot;, component: LoginPage, name: &quot;Login&quot;, useAsDefault: true },
  { path: &quot;/List&quot;, component: ListPage, name: &quot;List&quot; }
])
</code></pre>
<p>Angular 2 now knows about the list page, but we still need to navigate the user to that page at the appropriate time. Our next step is to allow users to log into their accounts, then navigate them to the new list page after they have successfully authenticated.</p>
<p>To do that, start by opening <code>app/shared/user/user.service.ts</code> and add the <code>login()</code> function below to the existing <code>UserService</code> class:</p>
<pre><code class="lang-TypeScript">login(user: User) {
  let headers = new Headers();
  headers.append(&quot;Content-Type&quot;, &quot;application/json&quot;);

  return this._http.post(
    Config.apiUrl + &quot;oauth/token&quot;,
    JSON.stringify({
      username: user.email,
      password: user.password,
      grant_type: &quot;password&quot;
    }),
    { headers: headers }
  )
  .map(response =&gt; response.json())
  .do(data =&gt; {
    Config.token = data.Result.access_token;
  })
  .catch(this.handleErrors);
}
</code></pre>
<p>This code hits one of our existing backend endpoints, and stores off a authentication token that weâ€™ll use later in this guide.</p>
<p>To use this <code>login()</code> function, return to <code>app/login/login.component.ts</code>, and add the following import to the top of the file:</p>
<pre><code class="lang-TypeScript">import {Router} from &quot;angular2/router&quot;;
</code></pre>
<p>Next, replace the current <code>constructor()</code> declaration with the code below, which injects Angular 2â€™s <code>Router</code> service:</p>
<pre><code class="lang-TypeScript">constructor(private _router: Router, private _userService: UserService) {
</code></pre>
<p>Finally, replace the <code>LoginPage</code>â€™s existing <code>login()</code> function with the code below:</p>
<pre><code class="lang-TypeScript">login() {
  this._userService.login(this.user)
    .subscribe(
      () =&gt; this._router.navigate([&quot;List&quot;]),
      (error) =&gt; alert(&quot;Unfortunately we could not find your account.&quot;)
    );
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>:</p>
<ul>
<li>You donâ€™t have to add <code>Router</code> to your <code>LoginPage</code> componentâ€™s <code>providers</code> array because itâ€™s already included in the parent <code>AppComponent</code> componentâ€™s <code>providers</code> list.</li>
<li>Refer to Angularâ€™s documentation for a <a href="https://angular.io/docs/ts/latest/api/router/Router-class.html">full list of the API available on the <code>Router</code> service</a>.</li>
</ul>
</blockquote>
<div class="exercise-end"></div>

<p>After this change you can now navigate between the login and list pages in your app:</p>
<p><img src="images/chapter3/android/7.gif" alt="Navigating on Android">
<img src="images/chapter3/ios/7.gif" alt="Navigating on iOS"></p>
<p>The power of NativeScript is you have the ability to use the same Angular conventions that youâ€™d use in a web appâ€”<code>@RouteConfig</code>, <code>Router</code>, and so forthâ€”yet get an app that fits right in on iOS and Android. Notice how on Android the hardware back button works as expected, and how your iOS app uses built-in iOS animations and conventions such as the back button.</p>
<blockquote>
<p><strong>TIP</strong>: There are other ways to share code between native and web apps besides the <code>shared</code> folder convention Groceries uses. For an approach that places web and native code in the same codebase, that also provides some additional tooling around testing and internationalization, check out <a href="https://github.com/NathanWalker/angular2-seed-advanced">Nathan Walkerâ€™s advanced Angular 2 seed project</a>.</p>
</blockquote>
<p>Now that weâ€™ve discussed how NativeScript apps and Angular 2 web apps are similar, letâ€™s move onto how theyâ€™re different. When youâ€™re building with NativeScript you have access to the entirety of iOS and Android, as well as the highly capable devices they run onâ€”enabling you to build rich experiences that go above and beyond what the web can offer.</p>
<p>The best part is, one NativeScript feature makes it trivial to tie into this native device functionality: NativeScript modules.</p>

			</div>
			<div class="chapter">
				<h2 id="nativescript-modules">NativeScript modules</h2>
<p>In this chapter you&#39;ll learn about NativeScript modules, which are the TypeScript modules in your app&#39;s <code>node_modules/tns-core-modules</code> folder. Whether you&#39;ve realized it or not, you&#39;ve already used several NativeScript modules, as all of the NativeScript UI elements are actually implemented with TypeScript code.</p>
<p>If you dig into <code>node_modules/tns-core-modules</code> you can get an idea of how these modules work. Start by finding the <code>node_modules/tns-core-modules/camera</code> folder, which includes the implementation of the camera module. It includes:</p>
<ul>
<li>a <code>package.json</code> file that sets the name of the module;</li>
<li>a file containing the module&#39;s Android implementation (<code>camera.android.js</code>);</li>
<li>a file containing the module&#39;s iOS implementation (<code>camera.ios.js</code>);</li>
<li>a file containing code shared by the Android and iOS implementations (<code>camera-common.js</code>)</li>
</ul>
<blockquote>
<p><strong>NOTE</strong>:</p>
<ul>
<li>You can refer to the <a href="https://nodejs.org/api/modules.html#modules_folders_as_modules">Node.js documentation on folders as modules</a> for more detailed information on how NativeScript organizes its modules.</li>
<li>The â€œtns-core-modulesâ€ package only includes compiled JavaScript code to cut down on file size. You can find the TypeScript code for each of these modules in the `<a href="https://github.com/NativeScript/nativescript">main NativeScript GitHub repo</a>, for instance hereâ€™s the <a href="https://github.com/NativeScript/NativeScript/tree/master/camera">camera moduleâ€™s source code</a>.</li>
</ul>
</blockquote>
<p>The <code>*.ios.*</code> and <code>*.android.*</code> naming convention should look familiar, as itâ€™s the exact same convention we used to include Android- and iOS-specific styling in <a href="#css">chapter 2.3</a>. NativeScript uses this same convention to implement its modules on iOS and Android. Now that you know where these modules are, let&#39;s take a closer look at what else they can do for your app, starting with a closer looks at what you can do with NativeScriptâ€™s UI elements.</p>
<h3 id="ui-elements">UI elements</h3>
<p>So far, youâ€™ve only used NativeScript UI elements by including them in an Angular 2 componentâ€™s <code>template</code>, but you can also programmaticly create and access UI elements, and each UI element has a set of properties and methods you can use to customize your app. To see how this works lets access the <code>&lt;Page&gt;</code> UI element and make some changes to it.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Customize the Page
</h4>

<p>Open <code>app/pages/login/login.component.ts</code>, and add the following import to the top of the file:</p>
<pre><code class="lang-TypeScript">import {Page} from &quot;ui/page&quot;;
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: All of the imports youâ€™ve seen to this point work because the TypeScript compiler resolves them against your projectâ€™s <code>node_modules</code> folder. For instance, <code>import {Component} from &quot;angular2/core&quot;</code> works because a <code>node_modules/angular2/core.d.ts</code> file exists. The two imports above are NativeScript module imports, and they work because your projectâ€™s <code>references.d.ts</code> file includes a reference to a TypeScript declaration file (a <code>.d.ts</code> file), that lives in <code>node_modules/tns-core-modules</code>, and which allows you to import modules from <code>node_modules/tns-core-modules</code> without any prefixes.</p>
</blockquote>
<p>Next, alter the same fileâ€™s existing <code>&quot;angular2/core&quot;</code> import to include the <code>OnInit</code> interface:</p>
<pre><code class="lang-TypeScript">import {Component, OnInit} from &quot;angular2/core&quot;;
</code></pre>
<p><code>OnInit</code> is a <a href="http://www.typescriptlang.org/docs/handbook/interfaces.html#class-types">TypeScript class interface</a>. To see how it works, make the following change to the declaration of your <code>LoginPage</code> class:</p>
<pre><code class="lang-TypeScript">export class LoginPage implements OnInit {
</code></pre>
<p>If youâ€™re using an editor that supports TypeScript, you should see an error that says something like <em>â€œClass â€˜LoginPageâ€™ incorrectly implements interface â€˜OnInitâ€™â€</em>. When you implement a TypeScript class interface, youâ€™re telling the TypeScript compiler that you must implement all methods that the interface requires. In the case of <code>OnInit</code>, Angular 2 requires you to implement a single <code>ngOnInit()</code> method. To implement it, add the following code within the <code>LoginPage</code> class:</p>
<pre><code class="lang-TypeScript">ngOnInit() {
  this.page.actionBarHidden = true;
  this.page.backgroundImage = this.page.ios ? &quot;res://bg_login.jpg&quot; : &quot;res://bg_login&quot;;
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: The <code>this.page.ios</code> check in this function can go away after NativeScript 2.0 is released. The check is there because of <a href="https://github.com/NativeScript/NativeScript/issues/1788">this bug</a>.</p>
</blockquote>
<p><code>ngOnInit</code> is one of several <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">component lifecycle hooks</a> that Angular 2 provides. As its name implies, <code>ngOnInit</code> gets invoked when Angular initializes this component.</p>
<p>Weâ€™ll discuss what the code within <code>ngOnInit()</code> does momentarily, but finally, to make these changes compile and run, change the <code>LoginPage</code>â€™s existing <code>constructor()</code> declaration to use the code below.</p>
<pre><code class="lang-TypeScript">constructor(private _router: Router, private _userService: UserService, private page: Page) {
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: Because the <code>Page</code> class is so commonly used in NativeScript apps, NativeScript provides this syntax as a shorthand for getting access to a componentâ€™s page.</p>
</blockquote>
<div class="exercise-end"></div>

<p>Now that you have this code in place, letâ€™s discuss what happens in these two lines:</p>
<pre><code class="lang-TypeScript">this.page.actionBarHidden = true;
this.page.backgroundImage = this.page.ios ? &quot;res://bg_login.jpg&quot; : &quot;res://bg_login&quot;;
</code></pre>
<p>This code uses an instance of the <a href="http://docs.nativescript.org/ApiReference/ui/page/Page"><code>Page</code> class</a> from the <a href="http://docs.nativescript.org/ApiReference/ui/page/README">NativeScript page module</a>, and sets two properties on itâ€”<code>actionBarHidden</code> and <code>backgroundImage</code>. Although you can peruse the NativeScript API documentation for a full list of these properties and what they do, if youâ€™re using a TypeScript-friendly IDE, you can get a full list of these properties at any point.</p>
<p><img alt="TypeScript autocomplete" class="plain" src="images/chapter4/typescript.png" style="border: 1px solid black;"></p>
<p>If you run your app you should see that the action barâ€”the bar beneath the status bar that had previously displayed on Androidâ€”is now hidden, and the page uses a gorgeous new background image:</p>
<p><img src="images/chapter4/android/1.png" alt="Background image on Android">
<img src="images/chapter4/ios/1.png" alt="Background image on iOS"></p>
<p>Letâ€™s look at a few other NativeScript modules you can use to help improve the look of this app.</p>
<h3 id="animations">Animations</h3>
<p>The ability to run robust and performant animations is the one of the biggest reasons people choose to build native mobile apps, and NativeScript makes running these animations simple. The NativeScript animation modules provides a <a href="https://docs.nativescript.org/ui/animation">series of JavaScript APIs</a> that let you perform a wide variety of animations to elements on the screen, including the following:</p>
<ul>
<li><a href="https://docs.nativescript.org/ui/animation#opacity">Opacity</a></li>
<li><a href="https://docs.nativescript.org/ui/animation#background-color">Background Color</a></li>
<li><a href="https://docs.nativescript.org/ui/animation#translate">Translations</a></li>
<li><a href="https://docs.nativescript.org/ui/animation#scale">Scaling</a></li>
<li><a href="https://docs.nativescript.org/ui/animation#rotate">Rotating</a></li>
</ul>
<p>Letâ€™s add a simple animation so you can see how they work.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a color animation
</h4>

<p>Open <code>app/pages/login/login.html</code> and add <code>#container</code> to the existing <code>&lt;StackLayout&gt;</code>:</p>
<pre><code class="lang-XML">&lt;StackLayout #container&gt;
</code></pre>
<p>The â€œ#â€ syntax is Angularâ€™s way of creating <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#!#local-vars">local template variables</a>, and youâ€™ll use this local variable to get a reference to the <code>&lt;StackLayout&gt;</code> element in TypeScript code momentarily.</p>
<p>Next, open <code>app/pages/login/login.component.ts</code> and add the following two lines at the top, which import the <a href="http://docs.nativescript.org/ApiReference/color/Color.html"><code>Color</code> class</a> from the NativeScript color module, and the <a href="http://docs.nativescript.org/ApiReference/ui/core/view/View"><code>View</code> class</a> from the NativeScript view module.</p>
<pre><code class="lang-TypeScript">import {Color} from &quot;color&quot;;
import {View} from &quot;ui/core/view&quot;;
</code></pre>
<p>After that, change the existing â€œangular2/coreâ€ import to include a few more classes:</p>
<pre><code class="lang-TypeScript">import {Component, ElementRef, OnInit, ViewChild} from &quot;angular2/core&quot;;
</code></pre>
<p>With these new imports in place, next, add the following property to the <code>LoginPage</code> class. Place it right under the <code>isLoggingIn = true;</code> line:</p>
<pre><code class="lang-TypeScript">@ViewChild(&quot;container&quot;) container: ElementRef;
</code></pre>
<p>This code uses Angularâ€™s <a href="https://angular.io/docs/ts/latest/api/core/ViewChild-var.html"><code>@ViewChild</code> decorator</a> to create a new property that points at the <code>&lt;StackLayout&gt;</code> element. To use that property, change the <code>LoginPage</code>â€™s <code>toggleDisplay()</code> function in the same file to use this code:</p>
<pre><code class="lang-TypeScript">toggleDisplay() {
  this.isLoggingIn = !this.isLoggingIn;
  let container = &lt;View&gt;this.container.nativeElement;
  container.animate({
    backgroundColor: this.isLoggingIn ? new Color(&quot;white&quot;) : new Color(&quot;#301217&quot;),
    duration: 200
  });
}
</code></pre>
<div class="exercise-end"></div>

<p>All NativeScript UI elements inherit from a base <a href="http://docs.nativescript.org/ApiReference/ui/core/view/View.html"><code>View</code> class</a>, which contains a number of useful methodsâ€”including the <code>animate()</code> method you used in the previous example.</p>
<p>One you have a reference to a UI element, you can call any of the methods that element inherits from <code>View</code>. In this case, you call the <code>&lt;StackLayout #container&gt;</code> elementâ€™s <code>animate()</code> method to change its background color over a duration of <code>200</code>, or 2/10 of a second. The effect is a subtle color change that helps user differentiate between the â€œSign Inâ€ and â€œSign Upâ€ functionality that your form provides.</p>
<p><img src="images/chapter4/android/2.gif" alt="Color animation on Android">
<img src="images/chapter4/ios/2.gif" alt="Color animation on iOS"></p>
<blockquote>
<p><strong>NOTE</strong>: You may notice that the text color is off with the brown background. Donâ€™t worry about that for now; weâ€™ll address that in chapter 6.</p>
</blockquote>
<p>The animation module is a lot of fun to play with, and itâ€™s easy to use too. All you need to do is get a reference to an element using <code>@ViewChild</code>, and then call that elementâ€™s <code>animate()</code> method. You may want to take a few minutes to look through our <a href="https://docs.nativescript.org/ui/animation#examples">animation samples</a> and try a few of these animations for yourself in Groceries.</p>
<p>For now, letâ€™s move on to another commonly used NativeScript UI element: the <code>&lt;ListView&gt;</code>.</p>
<h3 id="listview">ListView</h3>
<p>The ListView element lets you show a list of things on the screen, which is exactly what you need for showing a list of groceries. Before tying the grocery list to a backend API, let&#39;s start by seeing how to show a hardcoded list of items on the screen.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Build a list view
</h4>

<p>Open <code>app/pages/list/list.html</code> and replace its contents with the following code:</p>
<pre><code class="lang-XML">&lt;GridLayout&gt;
  &lt;ListView [items]=&quot;groceryList&quot; class=&quot;small-spacing&quot;&gt;
    &lt;template #item=&quot;item&quot;&gt;
      &lt;Label [text]=&quot;item.name&quot; class=&quot;medium-spacing&quot;&gt;&lt;/Label&gt;
    &lt;/template&gt;
  &lt;/ListView&gt;
&lt;/GridLayout&gt;
</code></pre>
<p>Weâ€™ll talk about the new syntax in a moment, but first letâ€™s define the class names used in the previous example. Open <code>app/app.css</code> and paste the following code at the bottom of the file, which defines a few utility class names you can use throughout your app:</p>
<pre><code class="lang-CSS">.small-spacing {
  margin: 5;
}
.medium-spacing {
  margin: 10;
}
</code></pre>
<p>Next, open <code>app/pages/list/list.component.ts</code> and replace its contents with the code below:</p>
<pre><code class="lang-TypeScript">import {Component, ElementRef, OnInit, ViewChild} from &quot;angular2/core&quot;;

@Component({
  selector: &quot;list&quot;,
  templateUrl: &quot;pages/list/list.html&quot;,
  styleUrls: [&quot;pages/list/list-common.css&quot;, &quot;pages/list/list.css&quot;]
})
export class ListPage implements OnInit {
  groceryList: Array&lt;Object&gt; = [];

  ngOnInit() {
    this.groceryList.push({ name: &quot;Apples&quot; });
    this.groceryList.push({ name: &quot;Bananas&quot; });
    this.groceryList.push({ name: &quot;Oranges&quot; });
  }
}
</code></pre>
<div class="exercise-end"></div>

<p>Your <code>ListPage</code> class now has a <code>groceryList</code> property that you fill with three objects in an <code>ngOnInit</code> handler. If you run your app and login, you should see the same list of groceries on the screen:</p>
<p><img src="images/chapter4/android/3.png" alt="List view on Android">
<img src="images/chapter4/ios/3.png" alt="List view on iOS"></p>
<p>How does this work? Letâ€™s return to this chunk of code:</p>
<pre><code class="lang-XML">&lt;ListView [items]=&quot;groceryList&quot; class=&quot;small-spacing&quot;&gt;
  &lt;template #item=&quot;item&quot;&gt;
    &lt;Label [text]=&quot;item.name&quot; class=&quot;medium-spacing&quot;&gt;&lt;/Label&gt;
  &lt;/template&gt;
&lt;/ListView&gt;
</code></pre>
<p>The <a href="http://docs.nativescript.org/ApiReference/ui/list-view/ListView"><code>&lt;ListView&gt;</code> UI element</a> requires an <code>items</code> property that points at an array of dataâ€”in this case, the <code>groceryList</code> array you added to your <code>ListPage</code> class. The list view element requires a child <code>&lt;template&gt;</code> element that specifies how to render each item in the <code>items</code> array.</p>
<p>The <code>#item</code> syntax is again Angular 2â€™s for syntax for creating local template variables. This gives you the ability to refer to each item in the array as <code>item</code> within the template. For this template, you render each item in the array with a single <code>&lt;Label&gt;</code> UI element, and because of the <code>[text]=&quot;item.name&quot;</code> binding, those labels contain the text from the <code>name</code> property of each of the items in <code>groceryList</code> TypeScript array.</p>
<p>Now that you have a hardcoded list displaying, letâ€™s see how to swap that out with live data.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Populate the list view
</h4>

<p>Open <code>app/shared/grocery/grocery.ts</code> and paste in the following code:</p>
<pre><code class="lang-TypeScript">export class Grocery {
  constructor(public id: string, public name: string) {}
}
</code></pre>
<p>This creates a simple <code>Grocery</code> model object that you can use throughout your app. Next, letâ€™s create a simple service that reads grocery lists from our backend.  Open <code>app/shared/grocery/grocery-list.service.ts</code> and paste in the following code:</p>
<pre><code class="lang-TypeScript">import {Injectable} from &quot;angular2/core&quot;;
import {Http, Headers} from &quot;angular2/http&quot;;
import {Config} from &quot;../config&quot;;
import {Grocery} from &quot;./grocery&quot;;
import {Observable} from &quot;rxjs/Rx&quot;;
import &quot;rxjs/add/operator/map&quot;;

@Injectable()
export class GroceryListService {
  constructor(private _http: Http) {}

  load() {
    let headers = new Headers();
    headers.append(&quot;Authorization&quot;, &quot;Bearer &quot; + Config.token);

    return this._http.get(Config.apiUrl + &quot;Groceries&quot;, {
      headers: headers
    })
    .map(res =&gt; res.json())
    .map(data =&gt; {
      let groceryList = [];
      data.Result.forEach((grocery) =&gt; {
        groceryList.push(new Grocery(grocery.Id, grocery.Name));
      });
      return groceryList;
    })
    .catch(this.handleErrors);
  }

  handleErrors(error: Response) {
    console.log(JSON.stringify(error.json()));
    return Observable.throw(error);
  }
}
</code></pre>
<p>The code here is very similar to the code you used in the <code>UserService</code> earlier in this guide. You use the <code>Http</code> serviceâ€™s <code>get()</code> method to load JSON data, and RxJSâ€™s <code>map()</code> function to format the data into an array of <code>Grocery</code> objects.</p>
<p>To use this service, open <code>app/pages/list/list.component.ts</code> and add the following two lines to the top of the file:</p>
<pre><code class="lang-TypeScript">import {Grocery} from &quot;../../shared/grocery/grocery&quot;;
import {GroceryListService} from &quot;../../shared/grocery/grocery-list.service&quot;;
</code></pre>
<p>Next, change the existing <code>groceryList</code> declaration to use the newly imported <code>Grocery</code> class instead of a generic <code>Object</code>:</p>
<pre><code class="lang-TypeScript">groceryList: Array&lt;Grocery&gt; = [];
</code></pre>
<p>Then, add the following <code>constructor</code> function within the <code>ListPage</code> class:</p>
<pre><code class="lang-TypeScript">constructor(private _groceryListService: GroceryListService) {}
</code></pre>
<p>Next, because youâ€™re injecting a service into your constructor you must also include it as a provider within your component decorator. To do so, replace the existing <code>@Component</code> decorator with the code below:</p>
<pre><code class="lang-TypeScript">@Component({
  selector: &quot;list&quot;,
  templateUrl: &quot;pages/list/list.html&quot;,
  styleUrls: [&quot;pages/list/list-common.css&quot;, &quot;pages/list/list.css&quot;],
  providers: [GroceryListService]
})
</code></pre>
<p>Finally, to kick off the call to <code>load()</code> when this page initializes, replace the existing <code>ngOnInit()</code> function with the code below:</p>
<pre><code class="lang-TypeScript">ngOnInit() {
  this._groceryListService.load()
    .subscribe(loadedGroceries =&gt; {
      loadedGroceries.forEach((groceryObject) =&gt; {
        this.groceryList.unshift(groceryObject);
      });
    });
}
</code></pre>
<p>The full version of your <code>app/pages/list/list.component.ts</code> file should now look like this:</p>
<pre><code class="lang-TypeScript">import {Component, ElementRef, OnInit, ViewChild} from &quot;angular2/core&quot;;
import {Grocery} from &quot;../../shared/grocery/grocery&quot;;
import {GroceryListService} from &quot;../../shared/grocery/grocery-list.service&quot;;

@Component({
  selector: &quot;list&quot;,
  templateUrl: &quot;pages/list/list.html&quot;,
  styleUrls: [&quot;pages/list/list-common.css&quot;, &quot;pages/list/list.css&quot;],
  providers: [GroceryListService]
})
export class ListPage implements OnInit {
  groceryList: Array&lt;Grocery&gt; = [];

  constructor(private _groceryListService: GroceryListService) {}

  ngOnInit() {
    this._groceryListService.load()
      .subscribe(loadedGroceries =&gt; {
        loadedGroceries.forEach((groceryObject) =&gt; {
          this.groceryList.unshift(groceryObject);
        });
      });
  }
}
</code></pre>
<div class="exercise-end"></div>

<p>Once you run this code you may expect to see a list of groceries, but instead youâ€™ll see this error in your terminal:</p>
<pre><code>JS: EXCEPTION: No provider for Http! (ListPage -&gt; GroceryListService -&gt; Http)
JS: STACKTRACE:
JS: Error: DI Exception
JS:     at NoProviderError.BaseException [as constructor] (/data/data/org.nativescript.groceries/files/app/tns_modules/angular2/src/facade/exceptions.js:16:23)
JS:     at NoProviderError.AbstractProviderError [as constructor] (/data/data/org.nativescript.groceries/files/app/tns_modules/angular2/src/core/di/exceptions.js:38:16)
</code></pre><p>The problem here is your new <code>GroceryListService</code> uses the <code>Http</code> service, but that <code>Http</code> service is never included in your componentâ€™s <code>providers</code> array. You could add <code>HTTP_PROVIDERS</code> to this array, as you did in <code>login.component.ts</code>, but it seems a little silly to add <code>HTTP_PROVIDERS</code> to every page that you build. And as it turns out, Angular 2 has a simpler way of handling this, by allowing you to add common providers to parent components.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Declaring providers
</h4>

<p>Open <code>app/pages/login/login.component.ts</code> and <em>remove</em> the following line from the top of the file:</p>
<div class="no-copy-button"></div>

<pre><code class="lang-TypeScript">import {HTTP_PROVIDERS} from &quot;angular2/http&quot;;
</code></pre>
<p>Next, in the same file, remove <code>HTTP_PROVIDERS</code> from the component decoratorâ€™s <code>providers</code> array. The array should now look this like:</p>
<pre><code class="lang-TypeScript">providers: [UserService],
</code></pre>
<p>After that, open <code>app/app.component.ts</code> and <em>add</em> the following import to the top of the file:</p>
<pre><code class="lang-TypeScript">import {HTTP_PROVIDERS} from &quot;angular2/http&quot;;
</code></pre>
<p>Finally, add <code>HTTP_PROVIDERS</code> to the <code>AppComponent</code> decoratorâ€™s <code>providers</code> array so that it looks like this:</p>
<pre><code class="lang-TypeScript">providers: [HTTP_PROVIDERS, NS_ROUTER_PROVIDERS],
</code></pre>
<div class="exercise-end"></div>

<p>Generally, itâ€™s only a good idea to declare providers in parent components if all of the componentâ€™s children actually use that provider. Although you <em>could</em> declare all your providers in <code>AppComponent</code>, your <code>providers</code> would become unwieldy as your app grows, and difficult to refactor as your app changes.</p>
<p>If you load the list page with the account you created earlier youâ€™ll see a blank page, as your account is newly created, and therefore your grocery list is empty. If you want to see some data to verify your changes worked, try logging in with the credentials â€œuser@nativescript.orgâ€ and â€œpasswordâ€. You should some data that looks something like this:</p>
<p><img src="images/chapter4/android/4.png" alt="Grocery data on Android">
<img src="images/chapter4/ios/4.png" alt="Grocery data on iOS"></p>
<p>At this point you have a list of data associated with each account, but a grocery list isnâ€™t very useful if you canâ€™t add new groceries to the list. Letâ€™s look at how to do that next.</p>
<h3 id="gridlayout">GridLayout</h3>
<p>In order to allow users to add to their grocery lists, you need to add a few additional UI controls to the list page. While you could use a simple <code>&lt;StackLayout&gt;</code> to stack up the controls you need, letâ€™s look at how to create a slightly more complex layout using the <code>&lt;GridLayout&gt;</code> element.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a GridLayout
</h4>

<p>Open <code>app/pages/list/list.html</code> and replace the contents of the file with the following code:</p>
<pre><code class="lang-XML">&lt;GridLayout rows=&quot;auto, *&quot;&gt;

  &lt;GridLayout row=&quot;0&quot; columns=&quot;*, auto&quot; class=&quot;add-bar&quot;&gt;
    &lt;TextField #groceryTextField hint=&quot;Enter a grocery item&quot; col=&quot;0&quot;&gt;&lt;/TextField&gt;
    &lt;Image src=&quot;res://add&quot; col=&quot;1&quot;&gt;&lt;/Image&gt;
  &lt;/GridLayout&gt;

  &lt;ListView [items]=&quot;groceryList&quot; row=&quot;1&quot; class=&quot;small-spacing&quot;&gt;
    &lt;template #item=&quot;item&quot;&gt;
      &lt;Label [text]=&quot;item.name&quot; class=&quot;medium-spacing&quot;&gt;&lt;/Label&gt;
    &lt;/template&gt;
  &lt;/ListView&gt;

&lt;/GridLayout&gt;
</code></pre>
<div class="exercise-end"></div>

<p>When your app runs with these changes your UI should now look like this:</p>
<p><img src="images/chapter4/android/5.png" alt="Updated view on Android">
<img src="images/chapter4/ios/5.png" alt="Updated view on  iOS"></p>
<p>To break down how this layout works, letâ€™s start with the outer structure of the markup:</p>
<pre><code class="lang-XML">&lt;GridLayout rows=&quot;auto, *&quot;&gt;
  &lt;GridLayout row=&quot;0&quot; class=&quot;add-bar&quot;&gt;...&lt;/GridLayout&gt;
  &lt;ListView row=&quot;1&quot;&gt;...&lt;/ListView&gt;
&lt;/GridLayout&gt;
</code></pre>
<p>The outer grid layoutâ€™s <code>rows</code> attribute divides the screen into two rows, the first auto-sized according to its childrens&#39; height, and the other to sized to take up *, or the remaining height of the screen. You place UI elements into these rows using the zero-based <code>row</code> attribute. The inner grid layout is in the top row because of its <code>row=&quot;0&quot;</code> attribute, and the list view is in the bottom row because of its <code>row=&quot;1&quot;</code> attribute.</p>
<p>Grid layouts can also divide the screen into columns, which is what the inner grid layout does:</p>
<pre><code class="lang-XML">&lt;GridLayout columns=&quot;*, auto&quot; class=&quot;add-bar&quot;&gt;
  &lt;TextField col=&quot;0&quot;&gt;&lt;/TextField&gt;
  &lt;Image col=&quot;1&quot;&gt;&lt;/Image&gt;
&lt;/GridLayout&gt;
</code></pre>
<p>Here the <code>columns</code> attribute divides the top of the screen into two columns. The <code>col=&quot;0&quot;</code> attribute puts the text field in the first column, and the <code>col=&quot;1&quot;</code> attribute puts the â€œ+â€ image in the last column. Grid layouts are the most commonly used NativeScript layout, so you may wish to take a minute to play around with the <code>columns</code> and <code>rows</code> attributes to figure out how they work.</p>
<blockquote>
<p><strong>TIP</strong>:</p>
<ul>
<li>You can nest any of the <a href="http://docs.nativescript.org/ui/layout-containers.html">NativeScript layouts</a>â€”not just grid layouts.</li>
<li>You can pass numbers, percentages, and a variety of other values to create more complex grid layouts. Refer to the <a href="http://docs.nativescript.org/ui/layout-containers.html#gridlayout">grid layout docs</a> for more information.</li>
</ul>
</blockquote>
<p>Now that we have the UI ready, letâ€™s make the add button work.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Allow users to add groceries
</h4>

<p>Open <code>app/pages/list/list.html</code> and give the existing <code>&lt;TextField&gt;</code> a new <code>[(ngModel)]</code> attribute so that it looks like this:</p>
<pre><code class="lang-XML">&lt;TextField #groceryTextField [(ngModel)]=&quot;grocery&quot; hint=&quot;Enter a grocery item&quot; col=&quot;0&quot;&gt;&lt;/TextField&gt;
</code></pre>
<p>Next, give the same fileâ€™s image a new <code>tap</code> attribute binding, so that the full <code>&lt;Image&gt;</code> looks like this:</p>
<pre><code class="lang-XML">&lt;Image src=&quot;res://add&quot; (tap)=&quot;add()&quot; col=&quot;1&quot;&gt;&lt;/Image&gt;
</code></pre>
<p>With these attributes in place, your next steps are to define a new <code>grocery</code> property and <code>add()</code> method in your <code>ListPage</code> class. To do that, open <code>app/pages/list/list.component.ts</code> and add the following two properties to the <code>ListPage</code> class (right below the existing <code>groceryList</code> property):</p>
<pre><code class="lang-TypeScript">grocery: string = &quot;&quot;;
@ViewChild(&quot;groceryTextField&quot;) groceryTextField: ElementRef;
</code></pre>
<p>Next, add the following import to the top of the <code>list.component.ts</code> file:</p>
<pre><code class="lang-TypeScript">import {TextField} from &quot;ui/text-field&quot;;
</code></pre>
<p>Then, add the following <code>add()</code> function to the existing <code>ListPage</code> class:</p>
<pre><code class="lang-TypeScript">add() {
  if (this.grocery.trim() === &quot;&quot;) {
    alert(&quot;Enter a grocery item&quot;);
    return;
  }

  // Dismiss the keyboard
  let textField = &lt;TextField&gt;this.groceryTextField.nativeElement;
  textField.dismissSoftInput();

  this._groceryListService.add(this.grocery)
    .subscribe(
      groceryObject =&gt; {
        this.groceryList.unshift(groceryObject);
        this.grocery = &quot;&quot;;
      },
      () =&gt; {
        alert({
          message: &quot;An error occurred while adding an item to your list.&quot;,
          okButtonText: &quot;OK&quot;
        });
        this.grocery = &quot;&quot;;
      }
    )
}
</code></pre>
<p>In this function you first ensure the user didnâ€™t submit without typing a grocery. If the user did type something, you dismiss the deviceâ€™s keyboard with the TextField elementâ€™s <code>dismissSoftInput()</code> method, and then call a new <code>add()</code> method on the <code>GroceryListService</code>.</p>
<p>To finish this example you have to define that new <code>add()</code> method. To do so, open <code>app/shared/grocery/grocery-list.service.ts</code> and paste the following function into the <code>GroceryService</code> class:</p>
<pre><code class="lang-TypeScript">add(name: string) {
  let headers = new Headers();
  headers.append(&quot;Authorization&quot;, &quot;Bearer &quot; + Config.token);
  headers.append(&quot;Content-Type&quot;, &quot;application/json&quot;);

  return this._http.post(
    Config.apiUrl + &quot;Groceries&quot;,
    JSON.stringify({ Name: name }),
    { headers: headers }
  )
  .map(res =&gt; res.json())
  .map(data =&gt; {
    return new Grocery(data.Result.Id, name);
  })
  .catch(this.handleErrors);
}
</code></pre>
<div class="exercise-end"></div>

<p>The <code>add()</code> code should look familiar as youâ€™re again using the <code>Http</code> serviceâ€™s <code>post()</code> method to make an HTTP call to our backend, and then using RxJSâ€™s <code>map()</code> function to convert the returned data into a <code>Grocery</code> object. You consume that object in the <code>ListPage</code> componentâ€™s <code>add()</code> method, which adds the grocery to the pageâ€™s list by calling <code>this.groceryList.unshift()</code>, and then empties that pageâ€™s text field by setting <code>this.grocery</code> equal to <code>&quot;&quot;</code>.</p>
<pre><code class="lang-TypeScript">this._groceryListService.add(this.grocery)
  .subscribe(
    groceryObject =&gt; {
      this.groceryList.unshift(groceryObject);
      this.grocery = &quot;&quot;;
    },
    () =&gt; { ... }
  );
</code></pre>
<p>The end result looks like this:</p>
<p><img src="images/chapter4/android/6.gif" alt="Adding to a list on Android">
<img src="images/chapter4/ios/6.gif" alt="Adding to a list on iOS"></p>
<p>At this point you can add a grocery item and it will appear immediately in your listâ€”and, all of this is completely driven by a backend service. Pretty cool, huh?</p>
<p>Let&#39;s look at how you can polish this page with a NativeScript module for showing activity indicators.</p>
<h3 id="activityindicator">ActivityIndicator</h3>
<p>Currently there&#39;s a bit of a delay when you first visit the list page before groceries appear. This delay could confuse a new user, who might think the app is stuck rather than retrieving data from a backend.</p>
<p>In NativeScript apps you can use the <a href="http://docs.nativescript.org/ApiReference/ui/activity-indicator/README">ActivityIndicator</a> module to show a spinner icon in your UI while your app is busy performing actions. The ActivityIndicator is a relatively simple UI element as it primarily uses one attributeâ€”<code>busy</code>. When an ActivityIndicator&#39;s <code>busy</code> attribute is set to <code>true</code> the ActivityIndicator shows, and when its <code>busy</code> attribute is set to <code>false</code> it doesn&#39;t. Let&#39;s see how the module works by adding an ActivityIndicator to the list page.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add an ActivityIndicator
</h4>

<p>Open up <code>app/pages/list/list.html</code> and paste the following line immediately before the final <code>&lt;/GridLayout&gt;</code>:</p>
<pre><code class="lang-XML">&lt;ActivityIndicator [busy]=&quot;isLoading&quot; [visibility]=&quot;isLoading ? &#39;visible&#39; : &#39;collapse&#39;&quot; row=&quot;1&quot; horizontalAlignment=&quot;center&quot; verticalAlignment=&quot;center&quot;&gt;&lt;/ActivityIndicator&gt;
</code></pre>
<p>This binds the ActivityIndicatorâ€™s <code>busy</code> attribute to an <code>isLoading</code> property in the <code>ListPage</code> component. To define that property, open <code>app/pages/list/list.component.ts</code> and add the following line of code immediately under <code>grocery: string = &quot;&quot;</code>:</p>
<pre><code class="lang-TypeScript">isLoading = false;
</code></pre>
<p>Now that the property exists, your final step is to set this flag to to <code>true</code> when the grocery data is loading. To do that, change the existing <code>ngOnInit()</code> function to use the code below:</p>
<pre><code class="lang-TypeScript">ngOnInit() {
  this.isLoading = true;
  this._groceryListService.load()
    .subscribe(loadedGroceries =&gt; {
      loadedGroceries.forEach((groceryObject) =&gt; {
        this.groceryList.unshift(groceryObject);
      });
      this.isLoading = false;
    });
}
</code></pre>
<div class="exercise-end"></div>

<p>When you first visit the list page, you should now see the following loading indicators:</p>
<p><img src="images/chapter4/android/7.png" alt="ActivityIndicator on Android">
<img src="images/chapter4/ios/7.png" alt="ActivityIndicator on iOS"></p>
<blockquote>
<p><strong>TIP</strong>: You can apply the same <code>row</code> or <code>column</code> attribute to multiple UI controls to have them take up the same space on the screen. The UI control that is defined last will appear on top, which is why the <code>&lt;ActivityIndicator&gt;</code> appears on top of the <code>&lt;ListView&gt;</code> in the previous example.</p>
<pre><code class="lang-XML">&lt;ListView row=&quot;1&quot;&gt;...&lt;/ListView&gt;
&lt;ActivityIndicator row=&quot;1&quot;&gt;&lt;/ActivityIndicator&gt;
</code></pre>
</blockquote>
<p>To finish off this chapter, letâ€™s look at how you can use another NativeScript CSS feature to add a final bit of polish to how the list page loads.</p>
<p>In the following exercise youâ€™ll use an animation to fade in the pageâ€™s <code>&lt;ListView&gt;</code> after your data loads. However this time, instead of getting a reference to the <code>&lt;ListView&gt;</code> UI element and calling its <code>animate()</code> method, youâ€™ll instead use NativeScriptâ€™s CSS animations.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Using CSS animations
</h4>

<p> Start by opening <code>app/pages/list/list-common.css</code> and pasting in the following CSS at the top of the file:</p>
<pre><code class="lang-CSS">ListView {
  opacity: 0;
}
.visible {
  animation-name: show;
  animation-duration: 1s;
}
@keyframes show {
  from { opacity: 0; }
  to { opacity: 1; }
}
</code></pre>
<p>This code sets the starting opacity value of the <code>&lt;ListView&gt;</code> to <code>0</code> so that the control is hidden when the page loads. The code also defines a <code>visible</code> class name that changes the <code>opacity</code> of an element from <code>0</code> to <code>1</code> over one full second.</p>
<blockquote>
<p><strong>TIP</strong>: For background on how the CSS animations syntax works, feel free to refer to the <a href="https://github.com/NativeScript/docs/blob/master/ui/animation-css.md">NativeScript CSS animation documentation</a>, or <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations">external CSS animation guides</a>.</p>
</blockquote>
<p>Now that you have the CSS in place, your next step is to add the previously defined <code>&quot;visible&quot;</code> class name to the <code>&lt;ListView&gt;</code> control after data has loaded. To do that, start by opening <code>app/pages/list/list-component.ts</code> and adding the following new property right below the existing <code>isLoading = false;</code> line:</p>
<pre><code class="lang-TypeScript">listLoaded = false;
</code></pre>
<p>Next, in the same file, replace the existing <code>ngOnInit()</code> function with the following code, which sets the new <code>listLoaded</code> flag:</p>
<pre><code class="lang-TypeScript">ngOnInit() {
  this.isLoading = true;
  this._groceryListService.load()
    .subscribe(loadedGroceries =&gt; {
      loadedGroceries.forEach((groceryObject) =&gt; {
        this.groceryList.unshift(groceryObject);
      });
      this.isLoading = false;
      this.listLoaded = true;
    });
}
</code></pre>
<p>Finally, open <code>app/pages/list/list.html</code> and replace the existing <code>&lt;ListView&gt;</code> tag with the following code:</p>
<pre><code class="lang-XML">&lt;ListView [items]=&quot;groceryList&quot; row=&quot;1&quot; class=&quot;small-spacing&quot; [class.visible]=&quot;listLoaded&quot;&gt;
</code></pre>
<div class="exercise-end"></div>

<p>The key here is the list viewâ€™s <code>[class.visible]=&quot;listLoaded&quot;</code> binding, which automatically applies the <code>visible</code> CSS class name based on the state of the <code>listLoaded</code> TypeScript property.</p>
<p>The advantage of using CSS animations is that you avoid the need to reference specific UI elements in your TypeScript code; there was no need to create a local template variable. The CSS animation approach also help to keep your code decoupled. Your TypeScript code can focus on logic, and leave styling concerns to your CSS code.</p>
<p>If you try out your app you should now see a nice fade-in animation:</p>
<p><img src="images/chapter4/android/8.gif" alt="Loading animation on Android">
<img src="images/chapter4/ios/8.gif" alt="Loading animation on iOS"></p>
<p>Now that you have functional login and list pages, letâ€™s enhance the appâ€™s functionality as a grocery list management tool. In the next chapters you&#39;ll add functionality such as email validation, social sharing, and more. And youâ€™ll use one of NativeScript&#39;s most useful features to do so: npm modules.</p>
<blockquote>
<p><strong>TIP</strong>: There are several modules that come out of the box with your NativeScript installation that we did not have time to cover in this guideâ€”including a <a href="https://docs.nativescript.org/ApiReference/location/HOW-TO">location service</a>, a <a href="https://docs.nativescript.org/ApiReference/file-system/HOW-TO">file-system helper</a>, a <a href="https://docs.nativescript.org/ApiReference/timer/HOW-TO">timer module</a>, a <a href="https://docs.nativescript.org/ApiReference/camera/HOW-TO">camera module</a>, and a whole lot more. Make sure to peruse the â€œModules APIâ€ of the NativeScript documentation, or just look around your <code>node_modules/tns-core-modules</code> folder to see all of whatâ€™s available.</p>
</blockquote>

			</div>
			<div class="chapter">
				<h2 id="plugins-and-npm-modules">Plugins and npm modules</h2>
<p>As you build more complex apps, you&#39;ll likely run into functionality that is not implemented in the NativeScript modules. But no worries, as NativeScript lets you leverage <a href="https://www.npmjs.com/">npm</a> (node package manager) to import npm modules into your apps. Alternately, you can install NativeScript plugins, which are simply npm modules that can access native code and use Android and iOS SDKs, if required. </p>
<p>In this chapter, you&#39;ll install and use an external email validator module to verify the format of email addresses as they are entered on the registration screen. Then, you&#39;ll add a NativeScript plugin, <a href="https://www.npmjs.com/package/nativescript-social-share">NativeScript social share</a>, to let users share their grocery lists using their device&#39;s native sharing widget.</p>
<h3 id="using-npm-modules">Using npm modules</h3>
<p>It would be nice to be able to make sure people are entering well-formatted email addresses into your app on the registration screen. You could write this functionality yourself, but validating email addresses is <a href="http://stackoverflow.com/questions/46155/validate-email-address-in-javascript">surprisingly tricky</a>, and it&#39;s a lot easier to use one of many npm modules that already provide this validation. For Groceries let&#39;s see how to add this <a href="https://www.npmjs.com/package/email-validator">email-validator module</a> to test for valid addresses.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Install the email validator module
</h4>

<p>Return to your terminal and make sure that you are working in the root directory in your Groceries project folder, a.k.a. here:</p>
<div class="no-copy-button"></div>

<pre><code>sample-Groceries &lt;----------------
    â”œâ”€â”€ app
    â”‚   â””â”€â”€ ...
    â”œâ”€â”€ package.json
    â””â”€â”€ platforms
        â”œâ”€â”€ android
        â””â”€â”€ ios
</code></pre><p>From the root directory install the email-validator module:</p>
<pre><code>npm install email-validator --save
</code></pre><div class="exercise-end"></div>

<p>The install process does a few things in the background. First, because you added the <code>--save</code> flag, npm records this dependency in your app&#39;s <code>package.json</code>. If you open your <code>package.json</code> you should see <code>&quot;email-validator&quot;</code> in your app&#39;s <code>&quot;dependencies&quot;</code> array.</p>
<pre><code class="lang-JavaScript">&quot;dependencies&quot;: {
  &quot;email-validator&quot;: &quot;^1.0.4&quot;
}
</code></pre>
<p>The npm CLI also creates a <code>node_modules</code> folder in the root of your app. This folder contains the code for the email-validator module, which is a bit of validation logic in <code>node_modules/email_validator/index.js</code>. </p>
<blockquote>
<p><strong>TIP</strong>: By saving your app&#39;s npm dependencies in your <code>package.json</code> file, you can always regenerate your <code>node_modules</code> folder by running <code>npm install</code>. Because of this, it&#39;s a common practice to exclude the <code>node_modules</code> folder from source control. The Groceries app uses git for source control, and as such includes <code>node_modules/</code> in its <code>.gitignore</code>.</p>
</blockquote>
<p>Now that you have the module installed let&#39;s look at how to use it.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Use the email validator module
</h4>

<p>Open <code>/app/shared/user/user.ts</code> and replace the existing contents of the file with the code below:</p>
<pre><code class="lang-TypeScript">var validator = require(&quot;email-validator&quot;);

export class User {
  email: string;
  password: string;
  isValidEmail() {
    return validator.validate(this.email);
  }
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: The NativeScript framework&#39;s <code>require()</code> method is configured to look at the <code>&quot;main&quot;</code> value in an npm module&#39;s <code>package.json</code> file. In the case of this module, the <code>&quot;main&quot;</code> value is <code>&quot;index.js&quot;</code>. Therefore, when you run <code>require(&quot;email-validator&quot;)</code>, you&#39;re actually requiring the file at <code>node_modules/email_validator/index.js</code>. You could also type <code>require(&quot;email-validator/index&quot;)</code> to retrieve the same file.</p>
</blockquote>
<p>To make use of this validator, open <code>app/pages/login/login.component.ts</code> and paste the following code at the beginning of the existing <code>submit()</code> function:</p>
<pre><code class="lang-TypeScript">if (!this.user.isValidEmail()) {
  alert(&quot;Enter a valid email address.&quot;);
  return;
}
</code></pre>
<div class="exercise-end"></div>

<p>Now, if the user attempts to login or register with an invalid email address, theyâ€™ll see an alert that points out the error. However in order to test out this change youâ€™ll need to do one more thing.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Rebuild your app
</h4>

<p>As we mentioned in chapter 1.4, although the <code>tns livesync</code> command is smart enough to reload your app for most changes you make to your app, certain changes require a full buildâ€”most notably, changes to native files in <code>app/App_Resources</code>, new modules installed with <code>npm install</code>, and new NativeScript plugins.</p>
<p>For NativeScript to recognize this new email-validator npm module, type <code>Ctrl+C</code> in your terminal to kill the existing <code>tns livesync</code> watcher if itâ€™s still running, and then use <code>tns run</code> to rebuild your application and deploy it to an emulator or device.</p>
<pre><code>tns run ios --emulator
</code></pre><p>Or</p>
<pre><code>tns run android --emulator
</code></pre><p>After the app deploys you can again run the <code>livesync</code> command to setup the watcher again.</p>
<pre><code>tns livesync ios --emulator --watch
</code></pre><p>Or</p>
<pre><code>tns livesync android --emulator --watch
</code></pre><div class="exercise-end"></div>

<p>After your app launches again, if you type an invalid email address and attempt to login, you should see an alert that prevents the submission:</p>
<p><img src="images/chapter5/android/1.png" alt="Validation alert on Android">
<img src="images/chapter5/ios/1.png" alt="Validation alert on iOS"></p>
<p>In general npm modules greatly expand the number of things you&#39;re able to do in your NativeScript apps. Need date and time formatting? Use <a href="https://www.npmjs.com/package/moment">moment</a>. Need utility functions for objects and arrays? Use <a href="https://www.npmjs.com/package/lodash">lodash</a> or <a href="https://www.npmjs.com/package/underscore">underscore</a>. This code reuse benefit gets even more powerful when you bring NativeScript plugins into the picture.</p>
<blockquote>
<p><strong>WARNING</strong>: Not all npm modules work in NativeScript apps. Specifically, modules that depend on Node.js or browser APIs will not work, as those APIs do not exist in NativeScript. The NativeScript wiki contains a <a href="https://github.com/NativeScript/NativeScript/wiki/supported-npm-modules">list of some of the more popular npm modules that have been verified to work in NativeScript apps</a>.</p>
</blockquote>
<h3 id="using-nativescript-plugins">Using NativeScript plugins</h3>
<p>NativeScript plugins are npm modules that have the added ability to run native code and use iOS and Android frameworks. Because NativeScript plugins are just npm modules, a lot of the techniques you learned in the previous section still apply. The one big difference is in the command you use to install plugins. Let&#39;s look at how it works by installing the NativeScript social share plugin.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Install the social sharing plugin
</h4>

<p>Return to your terminal, make sure you&#39;re still in the root of your app, and run the following command:</p>
<pre><code>tns plugin add nativescript-social-share
</code></pre><div class="exercise-end"></div>

<p>The install process does the same thing that the <code>npm install</code> command doesâ€”including retrieving the module from npm, installing the module in <code>node_modules</code>, and saving the module as a dependency in your app&#39;s <code>package.json</code>â€”but the <code>tns plugin add</code> command additionally configures any native code that the plugin needs to use.</p>
<p>For example the <a href="https://github.com/NativeScript/push-plugin">NativeScript push plugin</a> uses both iOS and Android SDKs, and the <code>tns plugin add</code> command takes care of installing those. The <a href="https://github.com/tjvantoll/nativescript-flashlight">NativeScript flashlight plugin</a> needs permissions to use the camera on Android, and the <code>tns plugin add</code> command takes care of setting that up too.</p>
<p>Now that you&#39;ve installed the social share plugin, let&#39;s look at how to use it.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Use the social sharing plugin
</h4>

<p>Open <code>app/pages/list/list.component.ts</code> and add the following line at the top of the file, which requires the social share module you just installed:</p>
<pre><code class="lang-JavaScript">var socialShare = require(&quot;nativescript-social-share&quot;);
</code></pre>
<p>Next you have to build some UI that lets you share a grocery list. To do so, open <code>app/pages/list/list.html</code> and add the following code at the very top of the file:</p>
<pre><code class="lang-XML">&lt;ActionBar title=&quot;Groceries&quot;&gt;
  &lt;ActionItem text=&quot;Share&quot; (tap)=&quot;share()&quot; android.systemIcon=&quot;ic_menu_share_holo_dark&quot; ios.systemIcon=&quot;9&quot; ios.position=&quot;right&quot;&gt;&lt;/ActionItem&gt;
&lt;/ActionBar&gt;
</code></pre>
<p>This code defines an <a href="https://docs.nativescript.org/ApiReference/ui/action-bar/ActionBar">ActionBar</a>, which is a UI component that appears on the top of the screen, and which can optionally include menu items, or <a href="http://docs.nativescript.org/ApiReference/ui/action-bar/ActionItem"><code>&lt;ActionItem&gt;</code></a> components.</p>
<blockquote>
<p><strong>NOTE</strong>: On iOS devices, <code>&lt;ActionItem&gt;</code>s are placed from left to right in sequence; you can override that (as the code above does) by providing an <code>ios.position</code> attribute.</p>
</blockquote>
<p>Next, to add a bit of styling to this new <code>&lt;ActionBar&gt;</code>, add the following CSS to the top of your <code>app/app.css</code> file:</p>
<pre><code class="lang-CSS">ActionBar {
  background-color: black;
  color: white;
}
</code></pre>
<p>Finally, now that youâ€™ve installed and required the plugin, and setup a UI to use it, your last step is implementing the <code>&lt;ActionItem&gt;</code>&#39;s <code>tap</code> handler. Open <code>app/pages/list/list.component.ts</code> again and add the following function to the <code>ListPage</code> class:</p>
<pre><code class="lang-TypeScript">share() {
  let list = [];
  for (let i = 0, size = this.groceryList.length; i &lt; size ; i++) {
    list.push(this.groceryList[i].name);
  }
  let listString = list.join(&quot;, &quot;).trim();
  socialShare.shareText(listString);
}
</code></pre>
<div class="exercise-end"></div>

<p>This code takes the grocery data from the grocery list array, converts the data into a comma-separated string, and passes that string to the social share pluginâ€™s <code>shareText()</code> method.</p>
<blockquote>
<p><strong>WARNING</strong>: Because this section had you install a NativeScript plugin, youâ€™ll have to rebuild your app one last time in order to test your changes. If you donâ€™t remember how refer back to chapter 5.0 for instructions.</p>
</blockquote>
<p>After you run the app, you&#39;ll see a new button at the top of the screen. When you tap it, the native iOS or Android sharing widget will show to let you post your groceries to your social networks, or send them via email, message, or any other method you prefer.</p>
<p><img src="images/chapter5/android/2.gif" alt="Social sharing on Android">
<img src="images/chapter5/ios/2.gif" alt="Social sharing on iOS"></p>
<p>Pretty cool, huh? The ability to use npm modules greatly expands the number of things you&#39;re able to do in a NativeScript app. Need to compose emails in your app? Try out the <a href="https://www.npmjs.com/package/nativescript-email">NativeScript email plugin</a>. Need to use the clipboard in your app? Try out the <a href="https://www.npmjs.com/package/nativescript-clipboard">NativeScript clipboard plugin</a>.</p>
<p>If you&#39;re looking for NativeScript plugins start by searching both the <a href="http://plugins.telerik.com/nativescript">Telerik NativeScript Plugins Marketplace</a> and our <a href="http://plugins.nativescript.rocks">community-curated list of plugins on npm</a>. If you don&#39;t find the plugin you need, you can <a href="https://nativescript.ideas.aha.io/">request the plugin on our ideas portal</a>, or you can take a stab at <a href="https://docs.nativescript.org/plugins">creating the plugin yourself</a>.</p>
<p>Between NativeScript modules, npm modules, and NativeScript plugins, the NativeScript framework provides a lot of functionality you can use to build your next app. However, we&#39;ve yet to talk about NativeScript&#39;s most powerful feature: the ability to directly access iOS and Android APIs in TypeScript. Let&#39;s look at how it works.</p>

			</div>
			<div class="chapter">
				<h2 id="accessing-native-apis">Accessing native APIs</h2>
<p>The beauty of NativeScript is that you can write a native iOS or Android app in TypeScript, XML, and CSS without touching Swift, Objective-C, or Java, if you choose. But what if you want to present a different, more platform-specific UI to your users? Or if you want to access an iOS or Android API that NativeScript doesn&#39;t expose through a NativeScript module or plugin?</p>
<p>NativeScript gives you the option to dig into native code as needed, and to do so without leaving TypeScript. To show how this works in action, let&#39;s tweak a few of the UI elements in your app using native code.</p>
<h3 id="accessing-ios-apis">Accessing iOS APIs</h3>
<p>You may recall from earlier chapters that the hint color on your sign up screen could use a little more contrast. Notice the unappealing black on brown color of the text in the images below (if you can see the text at all).</p>
<p><img src="images/chapter6/android/1.png" alt="Bad contrast on Android">
<img src="images/chapter6/ios/1.png" alt="Bad contrast on iOS"></p>
<p>At the time of this writing, NativeScript doesnâ€™t expose a way to style a text fieldâ€™s hint color through CSSâ€”although <a href="https://github.com/NativeScript/NativeScript/issues/712">there is an open issue requesting the feature</a>â€”however, both iOS and Android have ways to accomplish this task, and with NativeScript you have direct access to these native APIs.</p>
<p>Letâ€™s start with iOS. If you run a <a href="https://www.google.com/#q=style%20ios%20text%20field%20hint%20text">generic search for â€œstyle iOS text field hint textâ€</a>, the first result is a <a href="http://stackoverflow.com/questions/1340224/iphone-uitextfield-change-placeholder-text-color">Stack Overflow post</a> that recommends setting a <code>UITextField</code>â€™s <code>attributedPlaceholder</code> property. Letâ€™s look at how to do that.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Change hint colors on iOS
</h4>

<p>Because there are multiple text fields in Groceries, weâ€™ll write the functionality to change hint colors as a utility that lives in your appâ€™s <code>utils</code> folder. Open <code>app/utils/hint-util.ts</code> and paste in the following code:</p>
<pre><code class="lang-TypeScript">import {Color} from &quot;color&quot;;
import {TextField} from &quot;ui/text-field&quot;;

declare var NSAttributedString: any;
declare var NSDictionary: any;
declare var NSForegroundColorAttributeName: any;

export function setHintColor(args: { view: TextField, color: Color }) {
  let dictionary = new NSDictionary(
    [args.color.ios],
    [NSForegroundColorAttributeName]
  );
  args.view.ios.attributedPlaceholder = NSAttributedString.alloc().initWithStringAttributes(
    args.view.hint, dictionary);
}
</code></pre>
<p>This code creates a function called <code>setHintColor()</code> that accepts a <code>&lt;TextField&gt;</code> and <code>Color</code>. Weâ€™ll talk about the contents of this function momentarily; first letâ€™s look at how to use it.</p>
<p>First, open <code>app/pages/login/login.html</code> and switch the two <code>&lt;TextField&gt;</code>s to use the following code, which adds a local template variable to each element:</p>
<pre><code class="lang-XML">&lt;TextField #email hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; [(ngModel)]=&quot;user.email&quot;
  autocorrect=&quot;false&quot; autocapitalizationType=&quot;none&quot;&gt;&lt;/TextField&gt;
&lt;TextField #password hint=&quot;Password&quot; secure=&quot;true&quot; [(ngModel)]=&quot;user.password&quot;&gt;&lt;/TextField&gt;
</code></pre>
<p>Next, open up <code>app/pages/login/login.component.ts</code> and add the following two properties under the existing <code>@ViewChild(&quot;container&quot;)</code> line:</p>
<pre><code class="lang-TypeScript">@ViewChild(&quot;email&quot;) email: ElementRef;
@ViewChild(&quot;password&quot;) password: ElementRef;
</code></pre>
<p>After that, add the following two imports to the top of the file:</p>
<pre><code class="lang-TypeScript">import {setHintColor} from &quot;../../utils/hint-util&quot;;
import {TextField} from &quot;ui/text-field&quot;;
</code></pre>
<p>Then, add the following function to the fileâ€™s <code>LoginPage</code> class:</p>
<pre><code class="lang-TypeScript">setTextFieldColors() {
  let emailTextField = &lt;TextField&gt;this.email.nativeElement;
  let passwordTextField = &lt;TextField&gt;this.password.nativeElement;

  let mainTextColor = new Color(this.isLoggingIn ? &quot;black&quot; : &quot;#C4AFB4&quot;);
  emailTextField.color = mainTextColor;
  passwordTextField.color = mainTextColor;

  let hintColor = new Color(this.isLoggingIn ? &quot;#ACA6A7&quot; : &quot;#C4AFB4&quot;);
  setHintColor({ view: emailTextField, color: hintColor });
  setHintColor({ view: passwordTextField, color: hintColor });
}
</code></pre>
<p>Finally, add a call to the new <code>setTextFieldColors()</code> in your <code>LoginPage</code>â€™s existing <code>toggleDisplay()</code> methodâ€”ideally immediately after the existing <code>this.isLoggingIn = !this.isLoggingIn</code> line:</p>
<pre><code class="lang-TypeScript">this.setTextFieldColors();
</code></pre>
<div class="exercise-end"></div>

<p>After your app refreshes with this change, you should now see a far more readable hint color:</p>
<p><img src="images/chapter6/ios/2.png" alt="Better contrast on iOS"></p>
<p>Letâ€™s back up to the contents of the <code>setHintColor()</code> function so we can discuss whatâ€™s going on here.</p>
<pre><code class="lang-TypeScript">let dictionary = new NSDictionary(
  [args.color.ios],
  [NSForegroundColorAttributeName]
);
args.view.ios.attributedPlaceholder = NSAttributedString.alloc().initWithStringAttributes(
  args.view.hint, dictionary);
</code></pre>
<p>By convention, NativeScript controls make their iOS and Android native implementations available via <code>ios</code> and <code>android</code> properties, respectively. In this code that means that <code>args.color.ios</code> resolves to a <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIColor_Class/"><code>UIColor</code></a>, and <code>args.view.ios</code> resolves to a <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITextField_Class/"><code>UITextField</code></a>. Once you have a reference to these controls you can set native properties on them directly in TypeScript, which this code does with the <code>UITextField</code>â€™s <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITextField_Class/#//apple_ref/occ/instp/UITextField/attributedPlaceholder"><code>attributedPlaceholder</code> property</a>.</p>
<p>The power with NativeScript is you can perform these customizations in TypeScriptâ€”thereâ€™s no need to jump into Xcode and write Objective-C or Swift. And this doesnâ€™t apply just to attributes. Notice the global <code>NSDictionary</code>, <code>NSAttributedString</code>, and <code>NSForegroundColorAttributeName</code> attributes. In NativeScript, all iOS and Android APIs are globally available to useâ€”again, directly in TypeScript code.</p>
<p>Admittedly, this code can seem a bit arcane if youâ€™ve never written an iOS app before, but the key here is that youâ€™re never limited by the APIs that NativeScript provides out of the box. Most of the time youâ€™ll be able to solve problems using the NativeScript module APIs or NativeScript plugins, but if you hit a scenario your app needs that NativeScript doesnâ€™t provide a module for, you can always hit the native APIs directly.</p>
<blockquote>
<p><strong>TIP</strong>:</p>
<ul>
<li>NativeScript provides TypeScript declaration files (<code>.d.ts</code> files) for all iOS and Android APIs. You can download the files using the links below. One word of warning though: because the declaration files include the entirety of the iOS and Android SDKs, theyâ€™re quite large, and can slow TypeScript builds to a crawl because of their sheer size. Nevertheless, the files can be invaluable during development, as they make accessing native APIs a whole lot easier.<ul>
<li><a href="https://raw.githubusercontent.com/NativeScript/NativeScript/master/ios.d.ts">iOS TypeScript declaration file</a></li>
<li><a href="https://raw.githubusercontent.com/NativeScript/NativeScript/master/android17.d.ts">Android TypeScript declaration file</a></li>
</ul>
</li>
<li>For detailed information on how NativeScript makes native APIs globally available, read about <a href="http://developer.telerik.com/featured/nativescript-works/">â€œHow NativeScript Worksâ€</a> on our blog, and <a href="http://docs.nativescript.org/core-concepts/accessing-native-apis-with-javascript">â€œAccessing Native APIs with JavaScriptâ€</a> on our documentation.</li>
</ul>
</blockquote>
<p>Letâ€™s move onto how to accomplish this same hint color task on Android.</p>
<h3 id="accessing-android-apis">Accessing Android APIs</h3>
<p>Much like with iOS, if youâ€™ve not a native Android developer, figuring out how to accomplish a task on Android often starts with a web search. If you run a <a href="https://www.google.com/#q=style%20android%20text%20field%20hint%20text">search for â€œstyle Android text field hint textâ€</a>, youâ€™ll end up on a <a href="http://stackoverflow.com/questions/6438478/sethinttextcolor-in-edittext">Stack Overflow answer</a> that recommends using a <a href="http://developer.android.com/reference/android/widget/TextView.html#attr_android:textColorHint"><code>android.widget.TextView</code>â€™s <code>setTextHintColor()</code> method</a>. Letâ€™s alter our code to do that.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Change hint colors on Android
</h4>

<p>Open <code>app/utils/hint-util.ts</code> and replace the existing contents of the file with the following code:</p>
<pre><code class="lang-TypeScript">import {Color} from &quot;color&quot;;
import {TextField} from &quot;ui/text-field&quot;;

declare var NSAttributedString: any;
declare var NSDictionary: any;
declare var NSForegroundColorAttributeName: any;

export function setHintColor(args: { view: TextField, color: Color }) {
  if (args.view.android) {
    args.view.android.setHintTextColor(args.color.android);
  }
  if (args.view.ios) {
    let dictionary = new NSDictionary(
      [args.color.ios],
      [NSForegroundColorAttributeName]
    );
    args.view.ios.attributedPlaceholder = NSAttributedString.alloc().initWithStringAttributes(
      args.view.hint, dictionary);
  }
}
</code></pre>
<div class="exercise-end"></div>

<p>Remember from the previous section that NativeScript makes native objects available via a <code>android</code> property. In this case <code>args.view.android</code> refers to a <a href="http://developer.android.com/reference/android/widget/TextView.html"><code>TextView</code></a>, and therefore has the <code>setHintTextColor()</code> method that the Stack Overflow post said to call.</p>
<p>One other thing to notice is the if checks that you added around each of the native calls. Your TypeScript code runs across both platforms, and iOS APIs are not available on Android (and vice versa). Testing for the existence of the native object properties is a common way to fork your code in NativeScript to avoid errors. And with this change in place, your hint colors on Android are now far more legible.</p>
<p><img src="images/chapter6/android/2.png" alt="Better contrast on Android"></p>
<p>Letâ€™s look at one last way we can improve the look of this app with native code.</p>
<h3 id="customizing-the-status-bar">Customizing the status bar</h3>
<p>At the time of this writing, NativeScript does not expose a way to make translucent status barsâ€”aka status bars that you can see through. There is an <a href="https://github.com/NativeScript/NativeScript/issues/601">open issue requesting this feature</a>, but as with anything else when building with NativeScript, you donâ€™t have to be limited by what NativeScript provides out of the box. Letâ€™s look at how you can use that power to make your status bars look a little nicer.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Making translucent status bars
</h4>

<p>Sometimes accomplishing tasks with native code is simple, as it was with setting hint text on Android, and sometimes it takes a little more work. Because setting a status barâ€™s appearance is slightly more involved, the code has been prepopulated in <code>app/utils/status-bar-util.ts</code>. There are a few comments that link to detailed information on the techniques used, if youâ€™re curious about how it all works.</p>
<p>Because this code changes the appearance of the status bar, weâ€™ll want to call this method as soon as possible, so that the status bar doesnâ€™t awkwardly update after the app has already loaded. Therefore to use this new utility, open <code>app/main.ts</code> and replace the contents of the file with the following code, which calls a new <code>setStatusBarColors()</code> before the app is bootstrapped.</p>
<pre><code class="lang-TypeScript">import {nativeScriptBootstrap} from &quot;nativescript-angular/application&quot;;
import {AppComponent} from &quot;./app.component&quot;;
import {setStatusBarColors} from &quot;./utils/status-bar-util&quot;;

setStatusBarColors();
nativeScriptBootstrap(AppComponent);
</code></pre>
<p>Finally, there are a few last CSS tweaks you to make to account for the now translucent status bars. On iOS a translucent status bar continues to take up space, so you need to adjust the content of the page to sit on top of the status barâ€™s location. To do so, open <code>app/platform.ios.css</code> and paste in the following code:</p>
<pre><code class="lang-CSS">Page {
  margin-top: -20;
}
</code></pre>
<p>Next, open <code>app/pages/list/list.ios.css</code> and paste in the following code, which moves the add bar down from underneath the list pageâ€™s <code>&lt;ActionBar&gt;</code>:</p>
<pre><code class="lang-CSS">.add-bar {
  margin-top: 20;
}
</code></pre>
<p>On Android a translucent does not take up space, so you need to add a bit of padding to the top of the list page so the status bar and <code>&lt;ActionBar&gt;</code> donâ€™t sit on top of one another. To do so, open <code>app/pages/list/list.android.css</code> and paste in the following code:</p>
<pre><code class="lang-CSS">ActionBar {
  padding-top: 10;
}
</code></pre>
<div class="exercise-end"></div>

<p>And with that, your status bar is now translucent and properly spaced on iOS and Android:</p>
<p><img src="images/chapter6/android/3.png" alt="Updated status bar on Android">
<img src="images/chapter6/ios/3.png" alt="Updated status bar on iOS"></p>
<p>And... that&#39;s it! You&#39;ve created a functional, cross-platform, backend-driven app to manage your grocery list. In the process you&#39;ve created a unique UI for Android and iOS, leveraged NativeScript plugins and npm modules, learned how to log in and register, managed backend services, created a list, and more. </p>
<p>Congratulations! Feel free to <a href="https://twitter.com/intent/tweet?text=I%20just%20built%20an%20iOS%20and%20Android%20app%20using%20@NativeScript%20%F0%9F%8E%89.%20You%20can%20too!%20http://docs.nativescript.org/start/getting-started%20%23opensource">share your accomplishment on Twitter</a> or <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fdocs.nativescript.org%2Fstart%2Fgetting-started&amp;p%5B">Facebook</a> to impress your friends ğŸ˜€.</p>
<h4 class="exercise-start">
    <b>Challenge</b>: Add the ability to delete groceries
</h4>

<p>As cool as Groceries is, itâ€™s currently missing one crucial feature for a grocery management app: the ability to delete groceries from the list.</p>
<p>The Groceries backend already supports deleting, but itâ€™s up to you to implement the feature in the app. You do get two hints though. First, below is a function you can use in the <code>GroceryListService</code> for performing the necessary HTTP call to delete a grocery:</p>
<pre><code class="lang-TypeScript">delete(id: string) {
  let headers = new Headers();
  headers.append(&quot;Authorization&quot;, &quot;Bearer &quot; + Config.token);
  headers.append(&quot;Content-Type&quot;, &quot;application/json&quot;);

  return this._http.delete(
    Config.apiUrl + &quot;Groceries/&quot; + id,
    { headers: headers }
  )
  .map(res =&gt; res.json())
  .catch(this.handleErrors);
}
</code></pre>
<p>Second, hereâ€™s an image you can use in your template for users to tap to delete items. One note though: the image is a white â€œXâ€, so youâ€™ll have to find a way to create a non-white background in order to see the image.</p>
<pre><code class="lang-XML">&lt;Image src=&quot;res://delete&quot;&gt;&lt;/Image&gt;
</code></pre>
<p>If you get stuck, the Groceries appâ€™s <a href="https://github.com/NativeScript/sample-Groceries/tree/angular-end">â€œangular-endâ€ branch</a> has a solution you can check.</p>
<div class="exercise-end"></div>

			</div>
			<div class="chapter">
				<h2 id="next-steps">Next steps</h2>
<p>Sadly our tutorial is now complete, but your journey with NativeScript is just beginning. Letâ€™s look at the some steps you can take to build your next app with NativeScript.</p>
<h3 id="join-the-nativescript-community">Join the NativeScript community</h3>
<p>Regardless of what you choose to do next with NativeScript, joining the NativeScript community is a great way to keep up with the latest and greatest in the NativeScript world. Here are some ways you can get involved:</p>
<ul>
<li><strong>Join the <a href="http://developer.telerik.com/wp-login.php?action=slack-invitation">NativeScript Community Slack channel</a></strong>. The channel is a great place to ask questions, and chat with others in the NativeScript community.</li>
<li><strong>Follow <a href="https://twitter.com/nativescript">@nativescript</a> on Twitter</strong> for updates on all things NativeScript.</li>
<li><strong>Sign up for the NativeScript newsletter on <a href="https://www.nativescript.org/">nativescript.org</a></strong>. The newsletter will deliver NativeScript articles, news, plugin updates, and more straight to your inbox.</li>
</ul>
<h3 id="start-your-own-app">Start your own app</h3>
<p>Although youâ€™re welcome to use Groceries as the basis of your own app, if you want to start a new app from scratch, the NativeScript CLI provides a number of built-in starting points. For example, you can start a new â€œhello worldâ€ app by running the <code>tns create</code> command:</p>
<pre><code>tns create my-app-name --template tns-template-hello-world-ng
</code></pre><p>If you want to start from a slightly more complete starting point, the <code>tns create</code> command also has additional values you can use with the <code>--template</code> option. For instance, the following command creates a NativeScript project with tab navigation already setup:</p>
<pre><code>tns create MyNextGreatApp --template tns-template-tab-navigation
</code></pre><blockquote>
<p><strong>TIP</strong>: A number of other templates are available to use with the <code>--template</code> option, including TypeScript templates and more. Refer to <a href="https://www.tjvantoll.com/2016/02/22/creating-nativescript-templates/">the full list of official templates</a> at any time.</p>
</blockquote>
<p>Regardless of which template you choose to start from, once you have your app up and running, letâ€™s look at some of the resources you can use as you develop.</p>
<h3 id="bookmark-nativescript-learning-resources">Bookmark NativeScript learning resources</h3>
<p>There are a variety of NativeScript learning materials that go above and beyond what was offered in this tutorial. You may wish to refer to any of the following as you take your app from a prototype to the app stores:</p>
<ul>
<li>The NativeScript team provides a series of <a href="https://www.nativescript.org/app-samples-with-code">real-world app samples</a> that are all open source on GitHub. These samples are great to reference as youâ€™re developing your application.</li>
<li>The <a href="https://www.nativescript.org/resources">NativeScript resources page</a> lists further NativeScript learning material, such as training, books, and screencasts.</li>
<li><a href="http://www.nativescriptsnacks.com/">NativeScript Snacks</a> is a collection of bite-sized video tutorialsâ€”perfect for learning how a NativeScript concept works quickly.</li>
<li>The NativeScript documentation site has detailed guides on topics that were out of scope for this guide, including <a href="http://docs.nativescript.org/core-concepts/testing">unit testing</a>, <a href="http://docs.nativescript.org/core-concepts/debugging">debugging</a>, <a href="http://docs.nativescript.org/core-concepts/transpilers">transpiling Babel or TypeScript code</a>, and <a href="http://docs.nativescript.org/core-concepts/publishing-ios-apps">publishing to the iOS App Store</a> and <a href="http://docs.nativescript.org/core-concepts/publishing-android-apps">Google Play</a>.</li>
</ul>
<h3 id="let-us-know-what-you-think">Let us know what you think</h3>
<p>Finally, weâ€™d love if you could take a minute to tell us what you thought about the this guide. Your feedback helps us make this tutorial better.</p>
<iframe src="https://docs.google.com/forms/d/1r0q8YJ7yzXcDClfu29FTFITvU1_x-2MdGjZBMPrSXCw/viewform?embedded=true" width="760" height="1300" style="max-width: 100%;" frameborder="0" marginheight="0" marginwidth="0">Loading...</iframe>

			</div>
		</div>
	</div>
</div>

<script src="scripts/built.js"></script>

</body>
</html>